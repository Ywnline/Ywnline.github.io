<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>初级算法学习步骤</title>
      <link href="/2019/09/03/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%AD%A5%E9%AA%A4/"/>
      <url>/2019/09/03/%E5%88%9D%E7%BA%A7%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<p>算法可以说是解决问题的步骤。<br>按常理来说学习算法要先掌握一定的数据结构。但因为数组也是一大数据结构，而且也是非常常用的东西，所以在最初，做一些用数组解决的问题（其实java里的数据结构也都是基于数组和类来实现各种数据结构）。</p><a id="more"></a><p>比如一维数组里：计算两个数组的交集，用数组实现约瑟夫环等等；二维数组里（平面坐标初级）：扫雷，边缘检测问题，生命游戏等等。之后进行对数据结构的掌握，会了常用数据结构之后，就可以进行深入的算法研究了。<br>所以这里的建议的顺序是：<br>熟习数组相关操作<br>熟习字符串相关操作<br>认识基础数据结构：线性表、顺序表、链表、栈、队列、树、哈希表、图等。并且自己实现以上数据结构<br>掌握使用提供的数据结构API。<br>排序算法、查找算法。<br>四个基本算法思想：穷举，递推，递归，概率。<br>数学问题，数论问题，数据结构问题，几何问题，字符串问题，大数运算问题。<br>五大常用算法：分治、动态规划（DP），贪心，回溯，分支界定。<br>多看算法题和算法书。</p><h2 id="详细内容"><a href="#详细内容" class="headerlink" title="详细内容"></a>详细内容</h2><p>注：这里都是用java语言作为例子解答代码进行讲解，同时附带的也都是java的api使用说明，但其实算法对语言依赖性不大，重要的是思想。本文提供给大家一个学习方案作为参考。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>内容：熟习数组的常用操作，可以做一些基础题，可以上leetcode或者别的算法题网站，刷掉初级算法题库里的数组10几个题目，这样对一维和二维数组的掌握灵活度就比较高了。<br>一个比较典型的二维数组逻辑题目：<br>旋转二维数组：给定一个n×n的二维矩阵表示一个图像，输出将图像旋转90度的样子。（不要用另一个矩阵来旋转）<br>题目具体内容点击标题可以进去查看。<br>其他数组例题：<br>两个数组的交集，数组实现约瑟夫环，简易扫雷，生命游戏等等。<br>其他数组的操作大家可以自行去看看别的题，锻炼一下数组的运用思想。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>内容：字符串的操作，比如回文串判定、字符串翻转等等。同样建议上题库做一些相应练习。在java里对应的API：string，stringbuilder，stringbuffer。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>此章内容具体参照：java数据结构和他的API<br>内容：这一部分需要自己先去学习一遍数据结构，然后自己写出来。掌握之后，再去查看api文档，最后学会如何使用api里的数据结构写算法，下面介绍的主要是api的对应方式。<br>1、基础数组、线性表：<br>（1）数组：<br>API：Arrays。<br>（2）线性表：<br>API：ArrayList。<br>2、链表：<br>链表是以节点类为基础的，每个节点类有一个成员变量是下一个节点。<br>API：LinkedList。<br>3、集合（java）：<br>API：Collections。<br>这个接口提供了很多常用方法，具体如何使用可以参照帮助文档。<br>4、向量：（可增长数组）<br>API：Vector接口提供方法与数组类似，具体查看API帮助手册。<br>5、栈：<br>自己先基于数组去实现。<br>API：Stack接口提供查看，移除，压入，查找，判空操作<br>6、队列、双端队列、优先队列：<br>（1）队列：<br>API：Queue。<br>（2）双端队列：<br>API：Deque。<br>（3）优先队列：<br>   API：PriorityQueue档。<br>7、哈希表（映射表）：<br>API：<br>（1）Hashmap提供了键—值对应的功能。<br>（2）TreeMap提供了可排序的映射表。<br>8、树：<br>树没有api，可以用上面学过的东西去实现它。<br>9、图：<br>图也是没有api的，用之前学过的结构可以构造。</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>内容：在排序里，需要了解这九大排序算法：<br>1、冒泡排序：每两个交换，每轮吧最大的放后面；<br>2、选择排序：每轮选出最大的放后面；<br>3、插入排序：一个线性表，一开始只有一个元素，加一个排一个；<br>4、希尔排序：<br>5、快速排序：<br>6、堆排序：<br>7、合并排序：<br>8、基数排序：<br>9、计数排序：</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>这个阶段要了解到查找算法在平时的应用，最基础的是直接查找和二分查找，但是有时候在不同场景会有一些优化。<br>1、二分法：对排序好的数组用，Collections提供了此方法<br>2、二分法的各种优化搜索：<br>3、数据结构中的查找：<br>（1）顺序表：同数组，序号或者关键字顺序、二分查找。<br>（2）链表：关键字查找，只能一个个往后找，返回引用。<br>（3）树：树或者二叉树遍历一个个找，二叉搜索树可以根据大小找，原理和二分法一样。平衡二叉树同而搜索树，红黑树效率高。<br>（4）图：深度优先遍历查找。</p><h3 id="4个基本算法思想"><a href="#4个基本算法思想" class="headerlink" title="4个基本算法思想"></a>4个基本算法思想</h3><p>此章节具体参照：4个基本算法思想：穷举、递推、递归、概率<br>内容：这4个基本算法思想是解决基础问题的很实用的方法。这里开始其实就已经是把所有需要的知识准备好了，之后就要开始解题了。<br>1、穷举：暴力破解，n层for循环。枚举每一种可能。<br>2、递推：简单的动态规划，根据递推公式，累加。<br>3、普通递归：化解问题逐渐变小（从n到1）<br>4、概率：使用random数量足够大的时候，得到近似结果。</p><h3 id="数学问题，数论问题，数据结构问题，几何问题，字符串问题，大数运算问题："><a href="#数学问题，数论问题，数据结构问题，几何问题，字符串问题，大数运算问题：" class="headerlink" title="数学问题，数论问题，数据结构问题，几何问题，字符串问题，大数运算问题："></a>数学问题，数论问题，数据结构问题，几何问题，字符串问题，大数运算问题：</h3><p>内容：这一块需要了解的是零散问题的应用。每一块我举几个例子，推荐大家还是上刷题网站吧零散的题给刷掉，不推荐直接做各个算法难题，先做这些零散题会对之后系统做算法有一些帮助。<br>以下我诺列一些题目，大家可以自己查查，刷题网站上也有。<br>1、数学问题：<br>罗马数字转换<br>Math函数的应用（自行查看api帮助文档）。<br>保留小数点的操作：例如String.format（“%.2f”,string）<br>2、数据结构问题：<br>约瑟夫环：具体点击这里<br>括号匹配：具体点击这里<br>链表排序、最短路径等等。<br>3、数论问题：<br>素数、完全数为代表的问题。<br>4、几何问题：<br>java里有API：抽象类shape——具体类line2d，Point2d提供了一些集合方法。<br>5、大数运算问题：<br>API：BigInteger，提供加减乘除模，大小比较，转化等运算。<br>6、字符串问题：<br>API：String大致包含这些方法：是否包含，比较（可不考虑大小写），第一次出现索引（前后），两个字符串的某个区域是否相等（regionmatches），replace替换，split（[，]）分割，substring删减，tochararray变成字符数组，tolow/toup，trim忽略前后空白，valueof把别的转换成字符串。</p><h3 id="五大常用算法"><a href="#五大常用算法" class="headerlink" title="五大常用算法"></a>五大常用算法</h3><p>五大算法：分治，回溯，贪心，DP（动态规划），分支界定。<br>内容在这一块是需要重点看看的，前4个是重点，也有非常多的经典例题。这一部分还是比较需要时间的，以下仅仅是介绍，点开链接具有详细的每个算法讲解。</p><p>1、分治法<br>首先看一下二分搜索：一串数，取中间的数并且平分两半，如果比中间数大，就去上半部分找，然后再两半……这样查找就是分治思想：把一个问题分解成若干个一样的小块。<br>具体详情：分治算法——五大常用算法之一<br>基本概念：<br>把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题。直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。</p><p>2、动态规划法<br>具体详情：动态规划——五大常用算法之一<br>基本概念：<br>动态规划（DP）就是：每走一步，都会根据之前的情况来决定这一步的走向，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。使用动态规划法一般会有一个递推公式（递推就是简单动态规划）。当然，最难找到的也是这个递推公式。</p><p>3、贪心算法<br>具体详情：贪心算法——五大常用算法之一<br>基本概念：<br>在对问题求解时，总是做出在当前看来是最好的选择。不从整体最优上加以考虑，所做出的仅是在某种意义上的局部最优解。<br>贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。<br>所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。</p><p>4、回溯算法<br>具体详情：回溯算法——五大常用算法之一<br>基本概念：<br>      回溯算法实际上一个类似枚举的搜索尝试过程（排列组合），主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。<br>回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。<br>     许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p><p>5、分支界定<br>这个算法个人没有仔细研究，可能是因为学的较浅没有经常用到。下面内容做一个参考：<br>基本描述<br>    类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。</p>]]></content>
      
      
      <categories>
          
          <category> 算法排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式</title>
      <link href="/2019/08/07/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/08/07/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>策略模式定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户</p><a id="more"></a><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>需要有一系列不同的算法，这些算法完成的工作是同样的，只是实现不同，强调以相同的方式调用所有的算法，减少算法类和使用算法类之间的耦合</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>使代码结构清晰，便于维护，简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试 每个算法的修改都不会影响到其他的算法</p><h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><p>商场商品价格计算，其中涉及到的有商品的单价，个数，折扣 折扣的策略有：</p><ul><li>固定折扣</li><li>满减</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">type CashSuper interface &#123;</span><br><span class="line">Accept(float64) float64</span><br><span class="line">&#125;</span><br><span class="line">//CashNormal normal strategy</span><br><span class="line">type CashNormal struct&#123;&#125;</span><br><span class="line">func (normal CashNormal) Accept(money float64) float64 &#123;</span><br><span class="line">return money</span><br><span class="line">&#125;</span><br><span class="line">//CashRebate</span><br><span class="line">type CashRebate struct &#123;</span><br><span class="line">moneyRebate float64</span><br><span class="line">&#125;</span><br><span class="line">func (re CashRebate) Accept(money float64) float64 &#123;</span><br><span class="line">return money * re.moneyRebate</span><br><span class="line">&#125;</span><br><span class="line">//CashReturn</span><br><span class="line">type CashReturn struct &#123;</span><br><span class="line">moneyCondition float64</span><br><span class="line">moneyReturn    float64</span><br><span class="line">&#125;</span><br><span class="line">func (re CashReturn) Accept(money float64) float64 &#123;</span><br><span class="line">if money &gt;= re.moneyCondition &#123;</span><br><span class="line">return money - re.moneyReturn</span><br><span class="line">&#125;</span><br><span class="line">return money</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">type CashContext struct &#123;</span><br><span class="line">strategy CashSuper</span><br><span class="line">&#125;</span><br><span class="line">func NewCashContext(acceptType string) (cashFactory CashContext) &#123;</span><br><span class="line">switch acceptType &#123;</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;wrong type&quot;)</span><br><span class="line">case &quot;normal&quot;:</span><br><span class="line">cashFactory.strategy = CashNormal&#123;&#125;</span><br><span class="line">case &quot;0.8rebate&quot;:</span><br><span class="line">cashFactory.strategy = CashRebate&#123;moneyRebate: 0.8&#125;</span><br><span class="line">case &quot;300return100&quot;:</span><br><span class="line">cashFactory.strategy = CashReturn&#123;300, 100&#125;</span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">func (cashFactory CashContext) Accept(money float64) float64 &#123;</span><br><span class="line">return cashFactory.strategy.Accept(money)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统引论</title>
      <link href="/2019/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA/"/>
      <url>/2019/08/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p>操作系统（OS）是计算机上第一层软件，对硬件系统的首次扩充。主要作用管理好这些设备，提高利用率和吞吐量，并为用户和应用进程提供一个简单的接口，便于使用。</p><a id="more"></a> <hr><h2 id="操作系统的作用和目标"><a href="#操作系统的作用和目标" class="headerlink" title="操作系统的作用和目标"></a>操作系统的作用和目标</h2><h3 id="操作系统目标"><a href="#操作系统目标" class="headerlink" title="操作系统目标"></a>操作系统目标</h3><ul><li>方便性<ul><li>未配置OS的需要机器语言</li></ul></li><li>有效性<ul><li>提高系统资源利用率</li><li>提高系统吞吐量：合理组织计算机的工作流程，加速程序运行，缩短运行周期</li></ul></li><li>可扩充性<ul><li>可扩充性好坏与OS结构十分紧密联系 OS结构发展：无结构···模块化结构···层次结构···微内核结构（可以方便添加新的功能模块）</li></ul></li><li>开放性<ul><li>遵循世界标准规范，特别是遵循开放系统互连OSI国际标准</li></ul></li></ul><h3 id="操作系统作用"><a href="#操作系统作用" class="headerlink" title="操作系统作用"></a>操作系统作用</h3><ul><li>OS作为用户与计算机硬件系统之间的接口<ul><li>OS处于用户与计算机系统之间，用户通过OS来使用计算机系统</li><li>通过命令、系统调用、图标-窗口方式来完成通信</li></ul></li><li>OS作为计算机系统资源的管理者<ul><li>这些资源分为四大类：处理机、存储器、I/O设备、文件（数据和程序）</li><li>处理机 ： 用户分配和控制处理机</li><li>存储器 ： 主要负责内存分配和回收</li><li>I/O设备： 负责I/O设备的分配（回收）操作</li><li>文件管理： 用于实现对文件的存取、共享和保护</li></ul></li><li>OS 实现了对计算机资源的抽象<ul><li>完全无软件的计算机系统（裸机）</li><li>裸机上铺设I/O设备称为扩充器或虚拟机</li><li>I/O 设备实现对计算机硬件操作的第一层抽象</li><li>文件管理实现对计算机硬件操作的第二层抽象（功能更强的虚拟机）</li></ul></li></ul><h3 id="推动操作系统发展的主要动力"><a href="#推动操作系统发展的主要动力" class="headerlink" title="推动操作系统发展的主要动力"></a>推动操作系统发展的主要动力</h3><ul><li>不断提高计算机的利用率</li><li>方便用户</li><li>硬件的不断更新</li><li>计算机体系结构的不断发展</li><li>不断提出新的应用需求</li></ul><hr><h2 id="操作系统的发展过程"><a href="#操作系统的发展过程" class="headerlink" title="操作系统的发展过程"></a>操作系统的发展过程</h2><h3 id="未配置操作系统的计算机系统"><a href="#未配置操作系统的计算机系统" class="headerlink" title="未配置操作系统的计算机系统"></a>未配置操作系统的计算机系统</h3><ul><li>人工操作方式<ul><li>人工操作穿孔的纸带（卡片）</li><li>缺点:<ul><li>用户独占全机</li><li>CPU等待人工操作</li><li>人工操作方式严重降低了计算机利用率</li></ul></li></ul></li><li>脱机输入/输出方式<ul><li>将原有纸带装入纸带输入机，在一台外围机的控制下把纸袋上的数据（程序）放到磁盘上</li><li>有点：<ul><li>减少CPU空闲时间</li><li>提高I/O的速度</li></ul></li></ul></li></ul><h3 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h3><ul><li><p>单道批处理系统的处理流程</p><ul><li>监督程序将磁带上的作业一个一个顺序执行</li></ul></li><li><p>单道批处理系统缺点</p><ul><li>系统中资源得不到重复利用</li></ul></li></ul><h3 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h3><ul><li>多道批处理系统处理流程<ul><li>用户提交作业在外存上，排成一个队列（后备队列），作业调度根据一定算法，一次取多个调入内存，减少CPU的空当时间</li></ul></li><li>多道批处理系统的缺点<ul><li>资源利用率高</li><li>系统吞吐量达<ul><li>CPU和其他资源保持“忙碌”状态</li><li>仅当作业完成、或运行不下去时在进行切换，系统开销小</li></ul></li><li>平均周转时间长</li><li>无交互能力</li></ul></li></ul><h3 id="多道批处理系统需要解决的问题"><a href="#多道批处理系统需要解决的问题" class="headerlink" title="多道批处理系统需要解决的问题"></a>多道批处理系统需要解决的问题</h3><ul><li>问题：<ul><li>处理机挣用问题</li><li>内存分配和保护问题</li><li>I/O 设备分配问题</li><li>文件的组织和管理问题</li><li>作业管理问题</li><li>用户与系统的接口问题</li></ul></li></ul><h3 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h3><ul><li><p>分时系统的引入</p><ul><li>人——机交互</li><li>共享主机</li><li>分时系统是指，在一台计算机上连接多个鼠标、显示器的终端所组成的系统，该系统运行多个用户同时访问，共享主机资源</li></ul></li><li><p>分时系统的关键问题</p><ul><li>及时接受</li><li>及时处理</li></ul></li><li><p>分时系统的特新</p><ul><li>多路性</li><li>独立性</li><li>及时性</li><li>交互性</li></ul></li></ul><h3 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h3><ul><li><p>时间作为关键参数，收到某些信号“及时”、“实时”的反响</p></li><li><p>实时系统的类型</p><ul><li>工业控制系统</li><li>信息查询系统</li><li>多媒体系统</li><li>嵌入式系统</li></ul></li><li><p>实时任务类型</p><ul><li>周期性和非周期性实时任务</li><li>硬实时任务和软实时任务 （必须小于截至截止时间，不一定小于截止时间）</li></ul></li><li><p>实时系统与分时系统比较</p><ul><li>多路性</li><li>独立性</li><li>及时性</li><li>交互性</li><li>可靠性</li></ul></li></ul><hr><h2 id="微机操系统作发展史"><a href="#微机操系统作发展史" class="headerlink" title="微机操系统作发展史"></a>微机操系统作发展史</h2><ul><li>单用户单任务操作系统</li><li>单用户多任务操作系统</li><li>多用户多任务操作系统</li></ul><hr><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h3><ul><li>并行<ul><li>两个或多个事件在同一时刻运行</li></ul></li><li>并发<ul><li>两个或多个事件在同一时间间隔内发生</li></ul></li></ul><h3 id="引入进程"><a href="#引入进程" class="headerlink" title="引入进程"></a>引入进程</h3><p>在属于同一个计算程序和I/O程序之间只能顺序执行，即只有在计算程序执行告一段落后，才允许I/O程序执行，反之在执行I/O操作时计算程序也不能执行。但在为计算程序和I/O程序分别建立一个进程后两个进程可以并发执行</p><ul><li>进程<ul><li>在系统中能够独立运行并作为资源分配的基本单位，它是由一组机器指令、数据、堆栈等组成的，是以独立的活动实体。多个进程之间可以并发执行和交换信息。</li></ul></li></ul><h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><ul><li>共享与操作环境下的共享（含义不一致）<ul><li>共享<ul><li>某种资源能被大家使用</li></ul></li><li>操作系统环境下的共享（资源复用）<ul><li>指操作系统中的资源可供内存中多个并发执行的进程共同使用</li></ul></li></ul></li></ul><h3 id="互斥共享方式"><a href="#互斥共享方式" class="headerlink" title="互斥共享方式"></a>互斥共享方式</h3><p>系统中的某些资源虽然可以提供给多个进程（线程）使用，但在规定的时间内只有一个进程访问资源，为此建立了互斥访问</p><h3 id="同时访问方式"><a href="#同时访问方式" class="headerlink" title="同时访问方式"></a>同时访问方式</h3><p>系统中有一类资源允许同一时间由多个进程“同时”访问</p><p>并发和共享是多用户（多任务）OS的两个最基础的特征。</p><h2 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h2><h3 id="时分复用技术"><a href="#时分复用技术" class="headerlink" title="时分复用技术"></a>时分复用技术</h3><p>广泛利用时分复用技术来实现虚拟处理机、虚拟设备等，是资源利用率提高。原因：利用某设备为一个用户服务空闲时间又转去为其他用户服务，使得设备得到充分利用。</p><ul><li>虚拟处理技术</li><li>虚拟设备技术</li></ul><h3 id="空分复用技术"><a href="#空分复用技术" class="headerlink" title="空分复用技术"></a>空分复用技术</h3><p>将一个频率范围比较宽的信道划分为多个窄的信道（称为频带），其中的任何一个频带仅供一对用户通话。</p><hr><h2 id="操作系统的主要功能"><a href="#操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a>操作系统的主要功能</h2><h3 id="处理机管理功能"><a href="#处理机管理功能" class="headerlink" title="处理机管理功能"></a>处理机管理功能</h3><ul><li><p>进程控制</p><ul><li>进程控制的主要功能也就是作为穿件进程、撤销（终止）已接收的进程，控制进程在运行时状态的转换</li></ul></li><li><p>进程同步</p><ul><li>进程互斥方式<ul><li>访问临界资源时采用互斥：为每一个临界资源配置一把锁（W），当锁打开时才可以访问，关闭时禁止访问</li></ul></li><li>进程同步<ul><li>多个进程去做一件事情，有同步机构对他们执行次序加以协调：信号量机制</li></ul></li></ul></li><li><p>进程通信</p><ul><li>由源进程利用发送消息命令直接将消息挂载到目标进程得到消息队列上，由目标进程利用接收命令消息队列中取出消息</li></ul></li><li><p>调度</p><ul><li><p>作业调度</p><ul><li>任务是从后备队列中按照一定的算法选择处若干个作业，为他们分配运行所需资源，再讲这些作业调入内存后， 分别为他们建立进程，使它们成为可能获得处理机的就绪，并将它们插入到就绪队列中</li></ul></li><li><p>进程调度</p><ul><li>从进程的就绪队列中按照一定的算法选出一个进程，将处理机分配给他，并为他设置运行现场，使其投入执行</li></ul></li></ul></li></ul><h3 id="存储器管理功能"><a href="#存储器管理功能" class="headerlink" title="存储器管理功能"></a>存储器管理功能</h3><p>功能：<br>为多道程序的运行提供良好的环境，提高存储器利用率，方便用户使用，从逻辑上扩充内存。</p><ul><li><p>内存分配回收</p><ul><li>为每道程序分配内存空间，使他们“各得其所”</li><li>提高存储器利用率，减少不可用的内存空间</li><li>允许正在运行的程序申请附加内存空间，适应程序动态增长</li><li>OS 内存分配动态和静态两种方式：<ul><li>静态<ul><li>每个作业的内存空间在装入时确定，运行期间不能申请新的空间，不能在内存中移动</li></ul></li><li>动态<ul><li>每个作业的内存空间在装入时确定，运行期间可以继续申请新的空间，以适应程序数据的动态增长，运行在作业内存中移动</li></ul></li></ul></li></ul></li><li><p>内存保护</p><ul><li>确保每道用户程序都仅能在自己的空间内运行，彼此互不干扰</li><li>觉不允许用户程序访问操作系统的程序和数据，也不允许用户程序转移到非共享的其他用户程序中执行</li><li>内存保护机制设置两个界限寄存器<ul><li>对每条指令所要访问的地址进行检查，如发生越界，发出越界中断请求，停止程序的执行</li></ul></li></ul></li><li><p>地址映射</p><ul><li>逻辑空间中的逻辑地址转换为空间中与之对应的物理地址</li></ul></li><li><p>内存扩充</p><ul><li>借助于虚拟存储技术，从逻辑上扩充内存容量，让用户感觉到内存容量比实际大的多，让用户程序能并发运行</li><li>请求调入功能</li><li>置换功能：将不需要挂起至硬盘，需要的转入内存</li></ul></li></ul><h3 id="设备管理功能"><a href="#设备管理功能" class="headerlink" title="设备管理功能"></a>设备管理功能</h3><p>主要任务：<br>    完成用户进程提出的I/O请求，为用户分配所需的I/O设备，并完成指定的I/O操作<br>    提高CPU和I/O的利用率，提高I/O速度，方便用户使用I/O设备</p><ul><li>缓存管理<ul><li>I/O设备和CPU设备之间引入缓存，有效的缓和CPU和I/O设备速度不匹配的矛盾，提高CPU的利用率，进而提高系统吞吐量</li><li>常见缓存机制 都由 OS缓存机制管理：<ul><li>单缓存机制</li><li>能够实现双向同时传送数据的双缓存机制</li><li>能够供多个设备同时使用的公共缓存池机制</li></ul></li></ul></li><li>设备分配<ul><li>根据用户进程的I/O请求、系统现有资源情况及按照某种设备分配策略，为之分配所需设备</li></ul></li><li>设备处理<ul><li>实现CPU和设备控制器之间的通信</li></ul></li></ul><h3 id="文件管理功能"><a href="#文件管理功能" class="headerlink" title="文件管理功能"></a>文件管理功能</h3><p>功能：<br>    对用户文件和系统文件进行方便用户使用，并保证文件安全性。</p><ul><li>文件存储空间管理<ul><li>为每个文件分配必要的空间，提高外存利用率，进而提高文件系统的存、取速度。为此操作系统设置相应数据结构，堆内存空间进行分配和回收</li></ul></li><li>目录管理</li><li>文件读写管理和保护<ul><li>文件读写管理</li><li>文件保护</li></ul></li></ul><h3 id="操作系统与用户的接口"><a href="#操作系统与用户的接口" class="headerlink" title="操作系统与用户的接口"></a>操作系统与用户的接口</h3><ul><li>用户接口<ul><li>联机用户接口</li><li>脱机用户接口</li><li>图形用户接口</li></ul></li><li>程序接口</li></ul><h3 id="现代操作系统新功能"><a href="#现代操作系统新功能" class="headerlink" title="现代操作系统新功能"></a>现代操作系统新功能</h3><ul><li>系统安全<ul><li>认证技术</li><li>密码技术</li><li>访问控制技术</li><li>反病毒技术</li></ul></li><li>网络的功能和服务<ul><li>网络通信</li><li>资源管理</li><li>应用互操作</li></ul></li><li>支持多媒体<ul><li>接纳控制功能</li><li>实时调度</li><li>多媒体文件的存储</li></ul></li></ul><hr><h2 id="OS的设计"><a href="#OS的设计" class="headerlink" title="OS的设计"></a>OS的设计</h2>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/2019/08/04/Linux/"/>
      <url>/2019/08/04/Linux/</url>
      
        <content type="html"><![CDATA[<h2 id="LINUX常用命令（基础）"><a href="#LINUX常用命令（基础）" class="headerlink" title="LINUX常用命令（基础）"></a>LINUX常用命令（基础）</h2><ul><li>man 对你熟悉或不熟悉的命令提供帮助解释<ul><li>eg:man ls 就可以查看ls相关的用法<a id="more"></a></li><li>注：按q键或者ctrl+c退出，在linux下可以使用ctrl+c终止当前程序运行。</li></ul></li><li>ls 查看目录或者文件的属*，列举出任一目录下面的文件<ul><li>eg: ls /usr/man</li><li>ls -l</li><li>d表示目录(directory)，如果是一个”-“表示是文件，如果是l则表示是一个连接文件(link)</li><li>表示文件或者目录许可权限.分别用可读(r)，可写(w)，可运行(x)。</li></ul></li><li>cp 拷贝文件<ul><li>eg: cp filename1 filename2 //把filename1拷贝成filename2</li><li>cp 1.c netseek/2.c //将1.c拷到netseek目录下命名为2.c</li></ul></li><li>rm 删除文件和目录<ul><li>eg: rm 1.c //将1.c这个文件删除</li></ul></li><li>mv 移走目录或者改文件名<ul><li>eg: mv filename1 filename2 //将filename1 改名为filename2</li><li>mv qib.tgz ../qib.tgz //移到上一级目录</li></ul></li><li>cd 改变当前目录 pwd 查看当前所在目录完整路径<ul><li>eg: pwd //查看当前所在目录路径</li><li>cd netseek //进入netseek这个目录</li><li>cd //退出当前目录</li></ul></li><li>cat，more命令<ul><li>将某个文件的内容显示出来。两个命令所不同的是:cat把文件内容一直打印出来，而 more则分屏显示</li><li>eg; cat&gt;1.c //就可以把代码粘帖到1.c文件里，按ctrl+d 保存代码。</li><li>cat 1.c 或more 1.c //都可以查看里面的内容。</li><li>gcc -o 1 1.c //将1.c编译成.exe文件，我们可以用此命编译出代码。</li></ul></li><li>chmod 命令 权限修改 用法：chmod 一位8进制数 filename。<ul><li>eg: chmod u+x filenmame //只想给自己运行，别人只能读</li><li>//u表示文件主人， g 表示文件文件所在组。 o 表示其他人 ;r 表可读，w 表可写，x 表可以运行</li><li>chmod g+x filename //同组的人来执行</li></ul></li><li>clear，date命令<ul><li>clear:清屏，相当与DOS下的cls;date:显示当前时间。</li></ul></li><li>mount 加载一个硬件设备<ul><li>用法:mount [参数] 要加载的设备 载入点</li><li>eg: mount /dev/cdrom</li><li>cd /mnt/cdrom //进入光盘目录</li></ul></li><li>su 在不退出登陆的情况下，切换到另外一个人的身份<ul><li>用法: su -l 用户名(如果用户名缺省，则切换到root状态)</li><li>eg:su -l netseek (切换到netseek这个用户，将提示输入密码)</li></ul></li><li>whoami，whereis，which，id<ul><li>//whoami:确认自己身份</li><li>//whereis:查询命令所在目录以及帮助文档所在目录</li><li>//which:查询该命令所在目录(类似whereis)</li><li>//id:打印出自己的UID以及GID。(UID:用户身份唯一标识。GID:用户组身份唯一标识。每一个用户只能有一个唯一的UID和 GID)</li><li>eg: whoami //显示你自已登陆的用户名</li><li>whereis bin 显示bin所在的目录，将显示为：/usr/local/bin</li><li>which bin</li></ul></li><li>grep，find<ul><li>grep:文本内容搜索;find:文件或者目录名以及权限属主等匹配搜索</li><li>eg: grep success * 　　 /*查找当前目录下面所有文件里面含有success字符的文件</li></ul></li><li>kill 可以杀死某<ul><li>个正在进行或者已经是dest状态的进程</li><li>eg; ps ax</li></ul></li><li>passwd 可以设置口令</li><li>history 用户用过的命令<ul><li>eg: history //可以显示用户过去使用的命令</li></ul></li><li>!! 执行最近一次的命令<ul><li>mkdir命令</li><li>eg: mkdir netseek //创建netseek这个目录</li></ul></li><li>tar 解压命令<ul><li>eg: tar -zxvf nmap-3.45.tgz //将这个解压到nmap-3.45这个目录里</li></ul></li><li>finger 可以让使用者查询一些其他使用者的资料<ul><li>eg: finger //查看所用用户的使用资料</li><li>finger root //查看root的资料</li><li>本文讲解了Linux创建文件命令的方法 ,希望对您的学习有所帮助。</li><li>创建文件夹</li><li>mkdir aaa</li><li>mkdir -p aaa</li><li>创建文件命令</li><li>vi foo.txt</li><li>emacs foo.txt</li><li>echo “aaaa” &gt; foo.txt</li><li>cat &gt; foo.txt</li><li>清除命令</li><li>foo.txt</li><li>mkdir /home/u1 创建文件夹/home/u1</li><li>chown oracle /home/u1 表示改变目录所有者为oracle账户;</li><li>chgrp dba /home/u1 改变/home/u1目录为dba所有;</li><li>chmod 755 /home/u1 表示oracle账户对/home/u1目录有755权限;</li><li>rmdir /home/u1 表示删除/home/u1目录</li><li>hostname可以查看linux的计算机名;</li><li>whoami可以查看当前用户;</li><li>pwd显示当前路径;</li><li>df查看系统的硬件信息</li><li>ls -lrt l表示显示详细列表，-t表示按时间排序,-r反向排序</li><li>cat orcl_ora_3436.trc|grep bucket</li><li>以下查看相关文件内容:</li><li>more /etc/oratab</li><li>cat /etc/passwd</li><li>cat /etc/group</li><li>以上是Linux创建文件命令的方法。</li><li>linux中创建文件用touch 例如：touch 1.txt</li><li>删除文件用rm 例如：rm -f 1.txt</li><li>创建目录用mkdir 例如：mkdir daiyuanqi</li><li>删除空目录用rmdir 例如：rmdir daiyuanqi （有东西的目录不能删）</li><li>删除装有东西的目录就用rm -rf 例如rm -rf XXX</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7安装过程</title>
      <link href="/2019/08/04/CentOS7%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/08/04/CentOS7%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="安装UltraISO"><a href="#安装UltraISO" class="headerlink" title="安装UltraISO"></a>安装UltraISO</h2><p>官网搜索next</p><hr><h2 id="从U盘安装CentOS7-3教程"><a href="#从U盘安装CentOS7-3教程" class="headerlink" title="从U盘安装CentOS7.3教程"></a>从U盘安装CentOS7.3教程</h2><ul><li>准备工作:<ul><li>一台没系统的普通电脑<ul><li>u盘一个（大于1G，最小安装的话不超过1G，根据选择系统大小匹配U盘即可）</li><li>CentOS7.3 iso文件一个</li><li>UltraISO工具</li></ul></li></ul></li></ul><a id="more"></a><ul><li><p>制作U盘</p><ul><li>使用UltraISO工具 文件-》打开 选择你的ISO文件</li><li>先使用UltraISO刻录镜像至U盘内（PS:刻录的时候隐藏启动分区可以选成无，里面的packages文件夹可以删除，这个文件夹是没什么用的，而且大小挺大的，因为安装的时候有镜像在U盘内）</li></ul></li><li><p>开始安装</p><ul><li>把制作好的U盘插入需要安装Linux的电脑，把电脑的第一启动方式设置为U盘启动之后 会进入选择安装界面</li><li>接下来就是最重要的地方，关系着你能不能安装成功 我就是在这里卡了好久</li><li>先移动到第二项test &amp;Install</li><li>然后按e键编辑路径</li><li>将vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\x207\x20x86_64 quiet改成vmlinuz initrd=initrd.img linux dd quiet</li><li>ctrl+x</li><li>然后就能在显示出的列表中 查看你的硬盘信息，很清晰就能知道哪一个是你的U盘（一般显示的几个 格式为NTFS的都是你电脑自身的盘符，另外的一个就是你的U盘，记下你的U盘的盘符名字 我的就是sda4）使用ctrl+alt+del 重新启动电脑，重复上面的步骤 这一次 将vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\x207\x20x86_64 quiet改成vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sda4（你自己的U盘盘符） quiet ctrl+x 等待安装程序启动，进行CentOS的安装</li></ul></li><li><p>Linux引导安装</p><ul><li>选择中文安装</li><li>选择时区，设置时间，能够在网络与主机里面连接wifi之后 在时间设置里面使用网络时间</li><li>选择软件的安装源 U盘安装一般是默认选择 一般是Packages文件夹，不用管</li><li>比较常用的是最小化安装（安装快，只有命令行操作）</li><li>带有桌面的安装（一些配置和使用都可以图形化操作，较好用）</li><li>服务器版安装（特定组件可以省掉自己安装的很多问题），这里选择最小化安装，另外可以根据自己的需要从右面选择部分组件安装</li><li>刚开始接触Linux的朋友建议使用GHOME图形操作界面，好上手</li><li>网络和主机名里面配置网络信息</li><li>我这里是用的虚拟机安装 所以安装位置只能选择虚拟机，但是在真机安装的时候 需要选择具体的安装位置，如果之前电脑用过WIndows 硬盘已经分区了 需要进行磁盘释放，之后选择安装位置</li><li>全部信息确认完毕之后 就可以开始安装了</li><li>在这里可以新建用户 设置root操作 等待下方安装进度完成 之后就能进入Linux系统了</li></ul></li></ul><hr><h2 id="解决CentOS7-用U盘-无法进入安装界面"><a href="#解决CentOS7-用U盘-无法进入安装界面" class="headerlink" title="解决CentOS7 用U盘 无法进入安装界面"></a>解决CentOS7 用U盘 无法进入安装界面</h2><ul><li>这是用uefi方式启动的CentOS的版本是1708</li><li>首先按”e”键进入编辑界面将inst.stage2=hd:LABEL=CentOS\x207\x20x86_64  改为linux dd</li><li>按”ctrl + x”执行</li><li>然后找到那个驱动器</li><li>这里是sdd4</li><li>重新进入引导界面，修改以下信息</li><li>从inst.stage2=hd:开始，修改为/dev/sdd4 (这是自己的U盘位置)</li><li>按”ctrl + x”</li><li>稍等片刻，就可以安装CentOS7了</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单工厂模式</title>
      <link href="/2019/08/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/08/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>工厂模式是对象的生产器，解耦用户对具体的依赖。通过封闭、继承、多态把程序的耦合度降低，使程序更加灵活，容易修改，并易于复用。简单工厂模式中，各种运算方法类实现了运算接口，在业务上如果想添加一种算法方法，只需要增加一个实现接口的类，并且在工厂的类型中添加一个判断。这种设计适合用于业务逻辑并不多的情况，如果业务逻辑非常多，那么工作累就是一个很长的swuth…case结构这时候使用工厂模式会比较合适。</p><a id="more"></a><h2 id="主要类"><a href="#主要类" class="headerlink" title="主要类"></a>主要类</h2><ul><li>base - interface</li><li>concreteA - concrete class A</li><li>concreteB - concrete class B    </li><li>factory - in: choice; out: base</li></ul><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>工厂类中包含了必要的逻辑判断，根据客户端的选择条件实例化相应的类，对于客户端来说，去除了与具产品的依赖</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">设计一个计算器</span><br><span class="line">*/</span><br><span class="line">//Operation 操作接口</span><br><span class="line">type Operation interface &#123;</span><br><span class="line">SetNumber(float64, float64)</span><br><span class="line">GetResult() float64</span><br><span class="line">&#125;</span><br><span class="line">//BaseOperation 基础类</span><br><span class="line">type BaseOperation struct &#123;</span><br><span class="line">Operation</span><br><span class="line">NumberA float64</span><br><span class="line">NumberB float64</span><br><span class="line">&#125;</span><br><span class="line">func (bo *BaseOperation) SetNumber(numberA, numberB float64) &#123;</span><br><span class="line">bo.NumberA = numberA</span><br><span class="line">bo.NumberB = numberB</span><br><span class="line">&#125;</span><br><span class="line">//OperationAdd 加法运算</span><br><span class="line">type OperationAdd struct &#123;</span><br><span class="line">BaseOperation</span><br><span class="line">&#125;</span><br><span class="line">func (oa OperationAdd) GetResult() float64 &#123;</span><br><span class="line">return oa.NumberA + oa.NumberB</span><br><span class="line">&#125;</span><br><span class="line">//OperationSub 减法运算类</span><br><span class="line">type OperationSub struct &#123;</span><br><span class="line">BaseOperation</span><br><span class="line">&#125;</span><br><span class="line">func (os OperationSub) GetResult() float64 &#123;</span><br><span class="line">return os.NumberA - os.NumberB</span><br><span class="line">&#125;</span><br><span class="line">    //OperationFactory 工厂类</span><br><span class="line">type OperationFactory struct&#123;&#125;</span><br><span class="line">func (of OperationFactory) CreateOperation(oper string) Operation &#123;</span><br><span class="line">switch oper &#123;</span><br><span class="line">default:</span><br><span class="line">return nil</span><br><span class="line">case &quot;+&quot;:</span><br><span class="line">return new(OperationAdd)</span><br><span class="line">case &quot;-&quot;:</span><br><span class="line">return new(OperationSub)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//OperationUsage 工厂操作</span><br><span class="line">func OperationUsage() &#123;</span><br><span class="line">factory := new(OperationFactory)</span><br><span class="line">operation := factory.CreateOperation(&quot;+&quot;)</span><br><span class="line">operation.SetNumber(1, 2)</span><br><span class="line">fmt.Printf(&quot;this is add operation, 1+2=%v\n&quot;, operation.GetResult())</span><br><span class="line">operation = factory.CreateOperation(&quot;-&quot;)</span><br><span class="line">operation.SetNumber(2, 1)</span><br><span class="line">fmt.Printf(&quot;this is sub operation, 2-1=%v\n&quot;, operation.GetResult())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">设计一个工厂来生产各种厂商的手机</span><br><span class="line">其中初始的厂商有小米，苹果，华为</span><br><span class="line">*/</span><br><span class="line">//Phone interface</span><br><span class="line">type Phone interface &#123;</span><br><span class="line">ShowBrand()</span><br><span class="line">&#125;</span><br><span class="line">//IPhone apple</span><br><span class="line">type IPhone struct &#123;</span><br><span class="line">&#125;</span><br><span class="line">func (phone IPhone) ShowBrand() &#123;</span><br><span class="line">fmt.Println(&quot;[Phone Brand]: Apple&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//HPhone huawei</span><br><span class="line">type HPhone struct &#123;</span><br><span class="line">&#125;</span><br><span class="line">func (phone HPhone) ShowBrand() &#123;</span><br><span class="line">fmt.Println(&quot;[Phone Brand]: Huawei&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//XPhone xiaomi</span><br><span class="line">type XPhone struct &#123;</span><br><span class="line">&#125;</span><br><span class="line">func (phone XPhone) ShowBrand() &#123;</span><br><span class="line">fmt.Println(&quot;[Phone Brand]: Xiaomi&quot;)</span><br><span class="line">&#125;</span><br><span class="line">type PhoneFactory struct&#123;&#125;</span><br><span class="line">func (factory PhoneFactory) CreatePhone(brand string) Phone &#123;</span><br><span class="line">switch brand &#123;</span><br><span class="line">default:</span><br><span class="line">return nil</span><br><span class="line">case &quot;HW&quot;:</span><br><span class="line">return new(HPhone)</span><br><span class="line">case &quot;XM&quot;:</span><br><span class="line">return new(XPhone)</span><br><span class="line">case &quot;PG&quot;:</span><br><span class="line">return new(IPhone)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">func PhoneUsage() &#123;</span><br><span class="line">factory := PhoneFactory&#123;&#125;</span><br><span class="line">phone := factory.CreatePhone(&quot;HW&quot;)</span><br><span class="line">phone.ShowBrand()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">OperationUsage()</span><br><span class="line">PhoneUsage()</span><br><span class="line">&#125;</span><br><span class="line">result :</span><br><span class="line">this is add operation, 1+2=3</span><br><span class="line">this is sub operation, 2-1=1</span><br><span class="line">[Phone Brand]: Huawei</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用排序</title>
      <link href="/2019/08/03/%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/08/03/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>思路分析：在要排序的切片中，对当前还未排好的序列，从前往后对相邻的两个元素依次进行比较和调整，让较大的数往下沉，较小的往上冒。即，每当两相邻的元素比较后发现它们的排序与排序要求相反时，就将它们互换。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var sli = []int&#123;1, 43, 54, 62, 21, 66, 32, 78, 36, 76, 39&#125;</span><br><span class="line"></span><br><span class="line">func bubbleSort(sli []int) []int &#123;</span><br><span class="line">len := len(sli)</span><br><span class="line">//该层循环控制 需要冒泡的轮数</span><br><span class="line">for i := 1; i &lt; len; i++ &#123;</span><br><span class="line">//该层循环用来控制每轮 冒出一个数 需要比较的次数</span><br><span class="line">for j := 0; j &lt; len-1; j++ &#123;</span><br><span class="line">if sli[i] &lt; sli[j] &#123;</span><br><span class="line">sli[i], sli[j] = sli[j], sli[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return sli</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">res := bubbleSort(sli)</span><br><span class="line">fmt.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>思路分析：在要排序的切片中，选出最小的一个元素与第一个位置的元素交换。然后在剩下的元素当中再找最小的与第二个位置的元素交换，如此循环到倒数第二个元素和最后一个元素比较为止。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var sli = []int&#123;1, 43, 54, 62, 21, 66, 32, 78, 36, 76, 39&#125;</span><br><span class="line"></span><br><span class="line">func selectSort(sli []int) []int &#123;</span><br><span class="line">//双重循环完成，外层控制轮数，内层控制比较次数</span><br><span class="line">len := len(sli)</span><br><span class="line">for i := 0; i &lt; len-1; i++ &#123;</span><br><span class="line">//先假设最小的值的位置</span><br><span class="line">k := i</span><br><span class="line">for j := i + 1; j &lt; len; j++ &#123;</span><br><span class="line">//sli[k] 是当前已知的最小值</span><br><span class="line">if sli[k] &gt; sli[j] &#123;</span><br><span class="line">//比较，发现更小的,记录下最小值的位置；并且在下次比较时采用已知的最小值进行比较。</span><br><span class="line">k = j</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//已经确定了当前的最小值的位置，保存到 k 中。如果发现最小值的位置与当前假设的位置 i 不同，则位置互换即可。</span><br><span class="line">if k != i &#123;</span><br><span class="line">sli[k], sli[i] = sli[i], sli[k]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return sli</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>思路分析：在要排序的一切片中，假设前面的元素已经是排好顺序的，现在要把第n个元素插到前面的有序切片中，使得这n个元素也是排好顺序的。如此反复循环，直到全部排好顺序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var sli = []int&#123;1, 43, 54, 62, 21, 66, 32, 78, 36, 76, 39&#125;</span><br><span class="line"></span><br><span class="line">func insertSort(sli []int) []int &#123;</span><br><span class="line">len := len(sli)</span><br><span class="line">for i := 0; i &lt; len; i++ &#123;</span><br><span class="line">tmp := sli[i]</span><br><span class="line">//内层循环控制，比较并插入</span><br><span class="line">for j := i - 1; j &gt;= 0; j-- &#123;</span><br><span class="line">if tmp &lt; sli[j] &#123;</span><br><span class="line">//发现插入的元素要小，交换位置，将后边的元素与前面的元素互换</span><br><span class="line">sli[j+1], sli[j] = sli[j], tmp</span><br><span class="line">&#125; else &#123;</span><br><span class="line">//如果碰到不需要移动的元素，则前面的就不需要再次比较了。</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return sli</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">res := insertSort(sli)</span><br><span class="line">fmt.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>思路分析：选择一个基准元素，通常选择第一个元素或者最后一个元素。通过一趟扫描，将待排序列分成两部分，一部分比基准元素小，一部分大于等于基准元素。此时基准元素在其排好序后的正确位置，然后再用同样的方法递归地排序划分的两部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var sli = []int&#123;1, 43, 54, 62, 21, 66, 32, 78, 36, 76, 39&#125;</span><br><span class="line"></span><br><span class="line">func quickSort(sli []int) []int &#123;</span><br><span class="line">//先判断是否需要继续进行</span><br><span class="line">len := len(sli)</span><br><span class="line">if len &lt;= 1 &#123;</span><br><span class="line">return sli</span><br><span class="line">&#125;</span><br><span class="line">//选择第一个元素作为基准</span><br><span class="line">base_num := sli[0]</span><br><span class="line">//遍历除了标尺外的所有元素，按照大小关系放入左右两个切片内</span><br><span class="line">//初始化左右两个切片</span><br><span class="line">left_sli := []int&#123;&#125;  //小于基准的</span><br><span class="line">right_sli := []int&#123;&#125; //小于基准的</span><br><span class="line">for i := 1; i &lt; len; i++ &#123;</span><br><span class="line">if base_num &gt; sli[i] &#123;</span><br><span class="line">//放入左边切片</span><br><span class="line">left_sli = append(left_sli, sli[i])</span><br><span class="line">&#125; else &#123;</span><br><span class="line">//放入右边切片</span><br><span class="line">right_sli = append(right_sli, sli[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//再分别对左边和右边的切片进行相同的排序处理方式递归调用这个函数</span><br><span class="line">left_sli = quickSort(left_sli)</span><br><span class="line">right_sli = quickSort(right_sli)</span><br><span class="line"></span><br><span class="line">//合并</span><br><span class="line">left_sli = append(left_sli, base_num)</span><br><span class="line">return append(left_sli, right_sli...)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">res := quickSort(sli)</span><br><span class="line">fmt.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树</title>
      <link href="/2019/08/02/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/08/02/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>回顾整理二叉树遍历相关内容。 对于二叉树而言，其遍历有两种方式，一种是深度优先，即先优先向下进行遍历，一种是广度优先，逐层向下遍历。</p><a id="more"></a><h2 id="二叉树结构"><a href="#二叉树结构" class="headerlink" title="二叉树结构"></a>二叉树结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Tree struct &#123;</span><br><span class="line">Val   int</span><br><span class="line">Left  *Tree</span><br><span class="line">Right *Tree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p>Deepth-First-Search DFS， 对于深度优先而言，又有三种方式，即前序，中序和后序。前中后序之间的前中后，指的是根结点的位置。</p><h3 id="前序递归"><a href="#前序递归" class="headerlink" title="前序递归"></a>前序递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func PreOrder(root *Tree) []int &#123;</span><br><span class="line">    var result []int</span><br><span class="line">    if root == nil &#123;</span><br><span class="line">          return result</span><br><span class="line">    &#125;</span><br><span class="line">    result = append(result, root.Val)</span><br><span class="line">    result = append(result, PreOrder(root.Left)...)</span><br><span class="line">    result = append(result, PreOrder(root.Right)...)</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前序非递归"><a href="#前序非递归" class="headerlink" title="前序非递归"></a>前序非递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func PreOrderNonRecursive(root *Tree) []int &#123;</span><br><span class="line">var result []int</span><br><span class="line">if root == nil &#123;</span><br><span class="line">return result</span><br><span class="line">&#125;</span><br><span class="line">stack := list.New()</span><br><span class="line">p := root</span><br><span class="line">for p != nil || stack.Len() != 0 &#123;</span><br><span class="line">for p != nil &#123;</span><br><span class="line">result = append(result, p.Val)</span><br><span class="line">stack.PushBack(p)</span><br><span class="line">p = p.Left</span><br><span class="line">&#125;</span><br><span class="line">if stack.Len() != 0 &#123;</span><br><span class="line">node := stack.Back()</span><br><span class="line">stack.Remove(node)</span><br><span class="line">p = node.Value.(*Tree).Right</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序递归"><a href="#中序递归" class="headerlink" title="中序递归"></a>中序递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func InOrder(root *Tree) []int &#123;</span><br><span class="line">var result []int</span><br><span class="line">if root == nil &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">result = append(result, PreOrder(root.Left)...)</span><br><span class="line">result = append(result, root.Val)</span><br><span class="line">result = append(result, PreOrder(root.Right)...)</span><br><span class="line">return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序非递归"><a href="#中序非递归" class="headerlink" title="中序非递归"></a>中序非递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func InOrderNonRecursive(root *Tree) []int &#123;</span><br><span class="line">var result []int</span><br><span class="line">if root == nil &#123;</span><br><span class="line">return result</span><br><span class="line">&#125;</span><br><span class="line">stack := list.New()</span><br><span class="line">p := root</span><br><span class="line">for p != nil || stack.Len() != 0 &#123;</span><br><span class="line">for p != nil &#123;</span><br><span class="line">stack.PushBack(p)</span><br><span class="line">p = p.Left</span><br><span class="line">&#125;</span><br><span class="line">if stack.Len()  != 0 &#123;</span><br><span class="line">node := stack.Back()</span><br><span class="line">stack.Remove(node)</span><br><span class="line">result = append(result, node.Value.(*Tree).Val)</span><br><span class="line">p = node.Value.(*Tree).Right</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序递归"><a href="#后序递归" class="headerlink" title="后序递归"></a>后序递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func PostOrder(root *Tree) []int &#123;</span><br><span class="line">var result []int</span><br><span class="line">if root == nil &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">result = append(result, PreOrder(root.Left)...)</span><br><span class="line">result = append(result, PreOrder(root.Right)...)</span><br><span class="line">result = append(result, root.Val)</span><br><span class="line">return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序非递归"><a href="#后序非递归" class="headerlink" title="后序非递归"></a>后序非递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">func PostOrderNonRecursive(root *Tree) []int &#123;</span><br><span class="line">var result []int</span><br><span class="line">if root == nil &#123;</span><br><span class="line">return result</span><br><span class="line">&#125;</span><br><span class="line">stack := list.New()</span><br><span class="line">p := root</span><br><span class="line">lastVisit := new(Tree)</span><br><span class="line">for p != nil || stack.Len() != 0 &#123;</span><br><span class="line">for p != nil &#123;</span><br><span class="line">stack.PushBack(p)</span><br><span class="line">p = p.Left</span><br><span class="line">&#125;</span><br><span class="line">if stack.Len() != 0 &#123;</span><br><span class="line">node := stack.Back()</span><br><span class="line">if node.Value.(*Tree).Right != nil &amp;&amp; lastVisit != node.Value.(*Tree).Right &#123;</span><br><span class="line">p = node.Value.(*Tree).Right</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">result = append(result, node.Value.(*Tree).Val)</span><br><span class="line">stack.Remove(node)</span><br><span class="line">lastVisit = node.Value.(*Tree)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>Breadth-First-Search BFS 或者说是 Level Traversal，对于广度优先而言，其基于队列的数据结构，可以很简单的实现出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func LevelTraversal(root *Tree) []int &#123;</span><br><span class="line">var result []int</span><br><span class="line">if root == nil &#123;</span><br><span class="line">return result</span><br><span class="line">&#125;</span><br><span class="line">queue := list.New()</span><br><span class="line">queue.PushBack(root)</span><br><span class="line">for queue.Len() != 0 &#123;</span><br><span class="line">node := queue.Front()</span><br><span class="line">nTree := node.Value.(*Tree)</span><br><span class="line">queue.Remove(node)</span><br><span class="line">if nTree == nil &#123;</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">result = append(result, nTree.Val)</span><br><span class="line">queue.PushBack(nTree.Left)</span><br><span class="line">queue.PushBack(nTree.Right)</span><br><span class="line">&#125;</span><br><span class="line">return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意在for循环里，不能直接用 node.Value.(*Tree) == nil 来判断，因为interface特性，会认为其不为 nil，哪怕nTree为nil。 详细内容，可以参考 go interface机制，这里侧重算法，不再细讲。<br>总结</p><p>   二叉树遍历分为两种，一种是深度优先，一种是广度优先<br>   深度优先分为前，中，后序三种实现方式<br>   深度优先可以使用递归和非递归两种方式实现<br>   深度优先主要借助栈来实现<br>   广度优先主要借助队列来实现</p>]]></content>
      
      
      <categories>
          
          <category> 算法排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程的描述与控制</title>
      <link href="/2019/07/06/%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/07/06/%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="前趋图和程序执行"><a href="#前趋图和程序执行" class="headerlink" title="前趋图和程序执行"></a>前趋图和程序执行</h2><h3 id="前趋图"><a href="#前趋图" class="headerlink" title="前趋图"></a>前趋图</h3><p>指一个有向无循环图，用于描述进程之间执行的先后顺序</p><a id="more"></a><p><img src="/2019/07/06/进程的描述与控制/%E5%89%8D%E8%B6%8B%E5%9B%BE.png" alt="RUNOOB 图标"></p><h3 id="程序顺序执行"><a href="#程序顺序执行" class="headerlink" title="程序顺序执行"></a>程序顺序执行</h3><h4 id="程序的顺序执行"><a href="#程序的顺序执行" class="headerlink" title="程序的顺序执行"></a>程序的顺序执行</h4><p>一个程序由若干程序组组成，每一个程序段完成特定的功能，在执行时按照先后顺序依次执行，仅前一段程序执行后，才会执行下一段程序</p><h4 id="程序执行的特征"><a href="#程序执行的特征" class="headerlink" title="程序执行的特征"></a>程序执行的特征</h4><ul><li>顺序性<ul><li>严格按照规定顺序执行</li></ul></li><li>封闭性<ul><li>独占全集资源，只有程序本身可以改变资源状态，不受未接影响</li></ul></li><li>可再现性<ul><li>程序初始环境和执行环境相同，不论怎么执行都可获得相同结果</li></ul></li></ul><h3 id="程序并发执行"><a href="#程序并发执行" class="headerlink" title="程序并发执行"></a>程序并发执行</h3><h4 id="程序并发执行-1"><a href="#程序并发执行-1" class="headerlink" title="程序并发执行"></a>程序并发执行</h4><p>不存在钱趋关系，可以并发执行</p><h4 id="程序并发执行时的特征"><a href="#程序并发执行时的特征" class="headerlink" title="程序并发执行时的特征"></a>程序并发执行时的特征</h4><p>并发执行时，提高了系统的吞吐量、资源利用率，由于他们共享系统资源，是他们在执行程序时必形成相互制约关系</p><ul><li>间断性<ul><li>共享系统资源，完成统一任务相互合作，使得这些程序之间形成制约关系，导致程序“执行————暂停————执行”间断性活动规律</li></ul></li><li>失去封闭性<ul><li>资源共享，其中任一程序改变都会受到其他程序影响</li></ul></li><li>不可再现性<ul><li>失去封闭性，导致不可再现性</li></ul></li></ul><hr><h2 id="进程的描述"><a href="#进程的描述" class="headerlink" title="进程的描述"></a>进程的描述</h2><h3 id="进程的定义和特征"><a href="#进程的定义和特征" class="headerlink" title="进程的定义和特征"></a>进程的定义和特征</h3><h4 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h4><p>为了使并发执行的程序（含数据）都能独立运行，在操作系统中必须为配置一个专门的数据结构称之为进程控制块，一般情况下我们把进程实体就简称为进程，创建进程实质是创建进程实体中的PCB；撤销进程实质是撤销进程的PCB</p><ul><li>进程是程序的一次执行</li><li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动</li><li>进程是具有独立功能的程序在一个数据集合上运行的过程，他是系统进行资源分配和调度的一个独立单位</li></ul><p><strong>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</strong></p><h4 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h4><ul><li>动态性：进程的实质是进程实体的执行过程，“他由创建而产生，有调度而执行，有撤销而消亡”</li><li>并发性：进程实体同存于内存中，且能在一段时间内运行。程序（没有建立PCB）是不能参与并发执行的</li><li>独立性：进程实体是一个能独立运行、独立获得资源和独立接收调度的基本单位</li><li>异步性：进程是按异步方式运行的，即按各自独立的、不可预知的速度向前推进</li></ul><h3 id="进程的基本状态及转换"><a href="#进程的基本状态及转换" class="headerlink" title="进程的基本状态及转换"></a>进程的基本状态及转换</h3><h4 id="进程的三种基本状态"><a href="#进程的三种基本状态" class="headerlink" title="进程的三种基本状态"></a>进程的三种基本状态</h4><ul><li>就绪状态<ul><li>进程已获取除CUP外所有必要资源，只要获得CPU，便可立即执行</li><li>系统中有许多出于就绪状态的进程，通常将他们按照一定的策略排成一个队列，成就绪队列</li></ul></li><li>执行状态<ul><li>已获得CPU，正在执行的状态</li><li>单机处理系统中，只有一个进程处于执行状态</li><li>多处理机系统中，多个进程处于执行状态</li></ul></li><li>阻塞状态<ul><li>正在执行进程由于发生某些事件暂时无法继续执行的状态</li><li>此时OS把处理机分配给另外一个就绪进程，而让受阻进程处于暂停状态称为苏泽状态</li><li>在较大系统中根据阻塞原因不能，设置多个阻塞队列</li></ul></li></ul><h4 id="三种状态基本转换"><a href="#三种状态基本转换" class="headerlink" title="三种状态基本转换"></a>三种状态基本转换</h4><p><img src="/2019/07/06/进程的描述与控制/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png" alt="RUNOOB 图标"></p><h4 id="创建状态和终止状态"><a href="#创建状态和终止状态" class="headerlink" title="创建状态和终止状态"></a>创建状态和终止状态</h4><ul><li>创建状态<ul><li>申请一个空白PCB，向PCB中填写用于管理和控制的进程信息</li><li>为该进程分配运行时所必须的资源</li><li>把该进程转入就绪态并插入就绪队列中</li></ul></li></ul><p><strong>为保证进程调度必须在创建完成后进行，与确保进程控制块的完整性</strong></p><ul><li>终止状态<ul><li>等待操作系统善后处理</li><li>将其PCB清零，将PCB返还系统</li></ul></li></ul><p><img src="/2019/07/06/进程的描述与控制/%E8%BF%9B%E7%A8%8B%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81.png" alt="RUNOOB 图标"></p><h3 id="挂起操作和进程状态的转变"><a href="#挂起操作和进程状态的转变" class="headerlink" title="挂起操作和进程状态的转变"></a>挂起操作和进程状态的转变</h3><p>当挂起操作用于某个进程时，该进程将被挂起，意味着此时该进程处于静止状态。如果进程正在执行，它将暂停执行。若原本处于就绪状态，则该进程此时暂时不接受调度。与挂起操作对于的是激活操作</p><h4 id="挂起操作的引入"><a href="#挂起操作的引入" class="headerlink" title="挂起操作的引入"></a>挂起操作的引入</h4><ul><li>终端用户的需要<ul><li>运行时发现问题，暂停程序运行</li></ul></li><li>父进程请求<ul><li>父进程挂起自己某个进程</li></ul></li><li>负荷调节的需要</li><li>操作系统的需要</li></ul><h4 id="引入挂起原语操作后三个进程状态转换"><a href="#引入挂起原语操作后三个进程状态转换" class="headerlink" title="引入挂起原语操作后三个进程状态转换"></a>引入挂起原语操作后三个进程状态转换</h4><ul><li>活动就绪—&gt;静止就绪</li><li>活动阻塞—&gt;禁止阻塞</li><li>禁止就绪—&gt;活动就绪</li><li>禁止阻塞—&gt;活动阻塞</li></ul><p><img src="/2019/07/06/进程的描述与控制/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%9B%BE.png" alt="RUNOOB 图标"></p><h4 id="引入挂起操作后五个进程状态的转换"><a href="#引入挂起操作后五个进程状态的转换" class="headerlink" title="引入挂起操作后五个进程状态的转换"></a>引入挂起操作后五个进程状态的转换</h4><ul><li>NULL -&gt; 创建</li><li>创建 -&gt; 活动就绪</li><li>创建 -&gt; 静止就绪</li><li>执行 -&gt; 终止</li></ul><p><img src="/2019/07/06/进程的描述与控制/%E5%88%9B%E5%BB%BA%E7%BB%88%E6%AD%A2%E6%8C%82%E8%B5%B7.png" alt="RUNOOB 图标"></p><h3 id="进程管理中的数据结构"><a href="#进程管理中的数据结构" class="headerlink" title="进程管理中的数据结构"></a>进程管理中的数据结构</h3><h4 id="操作系统中用于管理控制的数据结构"><a href="#操作系统中用于管理控制的数据结构" class="headerlink" title="操作系统中用于管理控制的数据结构"></a>操作系统中用于管理控制的数据结构</h4><p>对每个资源和每个进程都是这了一个数据结构</p><h4 id="进程控制块PCB的作用"><a href="#进程控制块PCB的作用" class="headerlink" title="进程控制块PCB的作用"></a>进程控制块PCB的作用</h4><ul><li>作为独立运行基本单位的标志<ul><li>进程配置PCB后就表示他已是一个能在多道环境下独立运行的合法的基本单位，PCB称为进程存在系统的唯一标识</li></ul></li><li>能实现间断性运行方式<ul><li>采用停停走走的间断性的运行方式运行</li></ul></li><li>提供进程管理所需信息</li><li>提供进程调度所需信息</li><li>实现与其他进程的同步与通信</li></ul><h4 id="进程控制块中的信息"><a href="#进程控制块中的信息" class="headerlink" title="进程控制块中的信息"></a>进程控制块中的信息</h4><ul><li>进程标识符：唯一标识一个进程。一个进程有两个标识符<ul><li>外部标识符<ul><li>方便进程间调用</li></ul></li><li>内部标识符<ul><li>方便系统对进程调用</li></ul></li></ul></li><li>处理机状态<ul><li>通用寄存器</li><li>指令计时器</li><li>程序状态字PSW</li><li>用户占指针</li></ul></li><li>进程调度信息<ul><li>进程状态</li><li>进程优先级</li><li>进程调度所需的其他信息</li><li>事件</li></ul></li><li>进程控制信息<ul><li>进程和数据的地址</li><li>进程同步和通信机制</li><li>资源清单</li><li>连接指针</li></ul></li></ul><h4 id="进程控制块的组织方式"><a href="#进程控制块的组织方式" class="headerlink" title="进程控制块的组织方式"></a>进程控制块的组织方式</h4><ul><li>线性方式<ul><li>放入线性表中，将该表的首址存放在内存的一个专用区域中</li></ul></li><li>链接方式<ul><li>链接成一个对列</li></ul></li><li>索引方式<ul><li>根据状态不同建立几张索引表</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运输层</title>
      <link href="/2019/06/03/%E8%BF%90%E8%BE%93%E5%B1%82/"/>
      <url>/2019/06/03/%E8%BF%90%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>运输层为相互通信的应用进程提供逻辑通信</li><li>端口和套接字的意义</li><li>无连接的UDP的特点</li><li>面向连接的TCP的特点</li><li>在不可靠的网络上实现可靠网络的传输原理，停止等待协议和ARQ协议</li><li>TCP的滑动窗口、流量控制、拥塞控制和连接管理<a id="more"></a></li></ul><h2 id="运输层协议概述"><a href="#运输层协议概述" class="headerlink" title="运输层协议概述"></a>运输层协议概述</h2><hr><h3 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信"></a>进程之间的通信</h3><hr><p>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。<br>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。</p><p><strong>网络层是为主机之间提供逻辑通信；运输层为应用进程之间提供端到端的逻辑通信。</strong></p><p>真正进行通信的实体是主机中的进程，两天机器进程在做数据交换，两台主机进行通信就是两天主机中的<strong>应用进程互相通信</strong></p><h4 id="复用和分用"><a href="#复用和分用" class="headerlink" title="复用和分用"></a>复用和分用</h4><ul><li>复用：在发送方不同的应用进程都可以使用同一个运输层协议传输数据</li><li>分用：接收方的运输层再剥去报文的首尾部之后把这些数据交付给目的应用进程</li><li>UDP：无连接</li><li>TCP：面向连接<ul><li>运输层主要的两个协议<ul><li>用户数据报协议UDP</li><li>在传输数据之前不需要先建立连接，接收方收到UDP报文后不需要给出任何确认</li><li>传输控制协议TCP</li><li>提供面向连接服务<br><img src="/2019/06/03/运输层/clipboard.png" alt="RUNOOB 图标"></li></ul></li></ul></li><li>服务器端使用的端口号<ul><li>熟知端口号或系统端口号（0~1023）<br><img src="/2019/06/03/运输层/%E7%86%9F%E7%9F%A5%E7%AB%AF%E5%8F%A3.png" alt="RUNOOB 图标"></li></ul></li><li>客户端使用的端口号或短暂端口号（49152~65535）<ul><li>客户端收到确认之后端口自动释放</li></ul></li></ul><hr><h2 id="用户数据报协议-UDP"><a href="#用户数据报协议-UDP" class="headerlink" title="用户数据报协议 UDP"></a>用户数据报协议 UDP</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><ul><li>无连接，发送不需要建立，结束不需要释放</li><li>UDP使用尽最大女里交付：不保证可靠交付，   因此主机不需要维持复杂的连接状态</li><li>UDP是面向报文的：发送方的UDP对应用程序叫下来的报文，添加首部后乡下交付IP层，UDP对应用层交下来的报文既不合并也不拆分，只是保留这些报文的边界</li><li>无拥塞控制：可以丢数据，但不会慢</li><li>支持一对一、一对多、多对一、多对多</li><li>首部开销小，只有8个自己（TCP20个字节）</li></ul><h4 id="UDP首部格式"><a href="#UDP首部格式" class="headerlink" title="UDP首部格式"></a>UDP首部格式</h4><ul><li>用户数据包UDP有两个字段：<ul><li>数据字段</li><li>首部字段<ul><li>只有8个字节</li></ul></li></ul></li><li>源端口：源端口。在需要对方回信时使用，不需要全为0</li><li>目的端口：必须</li><li>长度：UDP用户数据报长度，最小值8（仅有首部）</li><li>检验和：检测UDP用户数据包在传输中是否有错，有错就丢弃<br>&nbsp;<br><img src="/2019/06/03/运输层/udp.png" alt="RUNOOB 图标"></li></ul><hr><h2 id="传输控制协议-TCP-概述"><a href="#传输控制协议-TCP-概述" class="headerlink" title="传输控制协议 TCP 概述"></a>传输控制协议 TCP 概述</h2><ul><li>端口号拼接到IP地址构成套接字或插口<ul><li>套接字socket=(IP地址：端口号)</li></ul></li><li>每一条TCP连接唯一的被通信两个端点（即两个套接字）所确定<ul><li>TCP连接：=(socket1,socket2) = (IP1:port1),(IP2:poer2)</li></ul></li></ul><hr><h2 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h2><h2 id="TCP-报文段的首部格式"><a href="#TCP-报文段的首部格式" class="headerlink" title="TCP 报文段的首部格式"></a>TCP 报文段的首部格式</h2><p>TCP面向字节流，但传输的数据单元式报文段。报文段分为首部和数据两部分，而TCP的全部功能都体现在他首部中各个字段的作用<br>TCP报文首部的前20个字节是固定的，后面有4n个字节是根据需要而增加的选项（n是整数）。因此TCP首部的最小长度时20字节<br>   <img src="/2019/06/03/运输层/tcp%E6%8A%A5%E6%96%87%E6%AE%B5.png" alt="RUNOOB 图标"></p><ul><li>源端口和目的端口 <ul><li>各占2个字节</li><li>分别写入源端口号和目的端口号</li></ul></li><li>序号（报文段序号）<ul><li>占4个字节</li><li>范围[0,2的32次方 - 1]，共2的32次方个序列号（4 294 967 296）。</li><li>增加到2的32次方-1后，下一个序号就又回到0</li><li>序号使用的是mod 2的32次方运算</li><li>TCP是面向字节流的。在一个TCP连接中传送的字节流的每一个字节都按序号排序</li><li>整个要传送的字节流的起始序号必须在连接建立时设置。</li><li>首部中的序号字段值则指的是本报文段所发送的数据的第一个字节的序号</li></ul></li><li>确认号<ul><li>占四个字节</li><li>期望收到对方下一个报文段的第一个数据字节的序号</li><li>若确认号 = N， 则表明:到序列号N-1位置的所有数据都已经确认收到</li><li>由于序号字段有32位长，可对4GB的数据进行编号。在一般情况下可保证当序号重复使用时，旧序号的数据早已通过网络早已通过网络到达终点</li></ul></li><li>数据偏移<ul><li>占4位</li><li>指出TCP报文段的数据起始处距离TCP报文段的起始处有多远</li><li>指出TCP报文段长度（实际意思）</li><li>由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的</li></ul></li><li>保留<ul><li>占6位</li><li>保留为后使用，但目前应置为0</li></ul></li><li>紧急URG<ul><li>当URG=1时，表明紧急指针字段有效，他告诉系统此报文段中有紧急数据，应该尽快处理（优先级高的数据），而不是按原来的排队顺序来传输</li></ul></li><li>确认ACK<ul><li>仅当ACK=1时确认好字段才有效</li><li>当ACK=0时确认好无效</li><li>TCP规定在连接建立后所有传送的报文段都必须把ACK设置为1</li></ul></li><li>推送PSH（PuSH）<ul><li>当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。</li><li>PSH = 1</li><li>几首方收到PSH的报文段，就立即交付给应用进程而不等到整个缓存都填满了之后再交付</li><li>很少使用</li></ul></li><li>复位RST<ul><li>RST = 1 而 ACK = 0时，表明是一个连接请求报文段。</li><li>若对方同意，则响应报文段中使用SYN=1 和 ACk = 1</li></ul></li><li>终止（FIN）<ul><li>释放一个连接</li><li>FIN = 1时，表明此报文段发送方的数据已发送完毕，并要求释放运输连接</li></ul></li><li>窗口  <ul><li>占2个字节</li><li>值[0, 2的16次方 - 1]之间的整数。</li><li>窗口指的是发送报文段的一方接收窗口</li><li>窗口值：从本报文段首部中的确认好算起，接收方目前允许对方发送的数据量（字节）</li><li>窗口值作为接收方让发送方设置其发送窗口的依据</li><li>窗口字段明确指出了现在允许对方返送的数据量。窗口值经常在动态变化</li></ul></li><li>检验和<ul><li>占2字节</li><li>检验和检验的范围包括首部和数据两部分</li><li>和UDP用户数据报一样，在计算检验和时，要在TCP报文钱加上12字节的伪首部。</li></ul></li><li>紧急指针<ul><li>占2字节</li><li>紧急指针仅在URG = 1 时才有意义</li><li>指出本报文段中的紧急数据的字节数</li><li>紧急指针指出了紧急数据的末尾数据的字节数</li><li>当窗口为零时也可以发送紧急指针</li></ul></li><li>选项<ul><li>长度可变</li><li>最长可达40字节</li><li>当没有使用“选项”时，TCP的首部长度时20个字节</li></ul></li></ul><hr><h2 id="TCP-可靠传输的实现"><a href="#TCP-可靠传输的实现" class="headerlink" title="TCP 可靠传输的实现"></a>TCP 可靠传输的实现</h2><h2 id="TCP-的流量控制"><a href="#TCP-的流量控制" class="headerlink" title="TCP 的流量控制"></a>TCP 的流量控制</h2><h3 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h3><h4 id="利用滑动窗口实现流量控制"><a href="#利用滑动窗口实现流量控制" class="headerlink" title="利用滑动窗口实现流量控制"></a>利用滑动窗口实现流量控制</h4><p>概念：发送方发送速率不要太快，让接收方来的及接收利用滑动窗口机制可以很方便的在TCP连接上实现对流量的控制</p><p><img src="/2019/06/03/运输层/%E6%B5%81%E6%8E%A7.png" alt="RUNOOB 图标"></p><p>发送方的发送窗口数值不能大于接收方接收窗口给出的数值<br>窗口单位是字节，而不是报文段<br>死锁：A在等待B，B在等待A</p><h5 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h5><p>TCP为每个连接设有一个持续计时器，只要TCP连接的一方收到对方的窗口通知，就启动持续计时器。若持续计时器时间到期，就发送一个零窗口探测报文段（包含一个字节），而对方再确认这个探测报文段时，给出了现在的窗口值。如果任然是0，那么收到这个报文段的一方就重新设置持续计时器，如果不是零，那么死锁就可以打破</p><h4 id="TCP的传输效率"><a href="#TCP的传输效率" class="headerlink" title="TCP的传输效率"></a>TCP的传输效率</h4><p>应用进程把数据传输到发送方缓存后剩下的就是TCP来处理了可以用不同处理机制TCP报文段的发送时机</p><ul><li>TCP维持一个变量，等于最大报文段长度MSS，只有缓存中的数据达到MSS字节时就组成一个TCP报文段发送出去</li><li>发送发进程来指明要求发送报文段，即TCP支持的推送操作（push）</li><li>发送方的一个计时器过期了，这时就把已有缓存数据装入报文段（不能超过最大报文段MSS）发送出去</li></ul><h5 id="Nagle算法："><a href="#Nagle算法：" class="headerlink" title="Nagle算法："></a>Nagle算法：</h5><p>发送方把缓存中第一个字节先发出去，其余的缓存起来，当接收到对方第一个字符确认后将缓存中的所有数据组装成一个报文段发送过去，同时随后到达的数据进行缓存，只有得到前一个报文段确认后才会继续发送下一个报文段</p><p>规定:当到达的数据已达到发送窗口大小的一半或已达到报文段最大长度时，立即发送下一报文段。这样做就可以提高网络吞吐量</p><p><strong>糊涂窗口综合征</strong><br><strong>接收方缓存数据空间较小</strong></p><p>让接受方等一段时间，当达到接收方已有充足空间、缓存有一半的空闲空间接收方发出确认报文，并向发送方通知当前窗口大小，发送方也不要发送较小的报文段，把数据积累成足够大的报文段或达到接收方缓存空间一半大小</p><p>综上所述：发送方不要发送较小报文段接收方缓存有一小点空间之后就急忙把窗口大小信息通知给发送发</p><hr><h2 id="TCP-的拥塞控制"><a href="#TCP-的拥塞控制" class="headerlink" title="TCP 的拥塞控制"></a>TCP 的拥塞控制</h2><h2 id="TCP-的运输连接管理"><a href="#TCP-的运输连接管理" class="headerlink" title="TCP 的运输连接管理"></a>TCP 的运输连接管理</h2>]]></content>
      
      
      <categories>
          
          <category> 计算应网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更新</title>
      <link href="/2019/03/03/%E6%9B%B4%E6%96%B0blog/"/>
      <url>/2019/03/03/%E6%9B%B4%E6%96%B0blog/</url>
      
        <content type="html"><![CDATA[<hr><p>博客内容更新</p><a id="more"></a><h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server 或 <span class="variable">$hexo</span> s</span><br></pre></td></tr></table></figure><h3 id="清空资源文件"><a href="#清空资源文件" class="headerlink" title="清空资源文件"></a>清空资源文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><h3 id="重新生成资源文件"><a href="#重新生成资源文件" class="headerlink" title="重新生成资源文件"></a>重新生成资源文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate 或 $ hexo g</span><br></pre></td></tr></table></figure><h3 id="发布文章到github-io"><a href="#发布文章到github-io" class="headerlink" title="发布文章到github.io"></a>发布文章到github.io</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy 或 hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
