{"meta":{"title":"Ywnline","subtitle":null,"description":null,"author":"Ywnline","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-08-02T07:34:41.000Z","updated":"2019-08-02T07:44:27.578Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-02T07:35:29.000Z","updated":"2019-08-02T07:44:21.001Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"初级算法学习步骤","slug":"初级算法学习步骤","date":"2019-08-03T06:51:05.000Z","updated":"2019-08-03T06:55:44.775Z","comments":true,"path":"2019/08/03/初级算法学习步骤/","link":"","permalink":"http://yoursite.com/2019/08/03/初级算法学习步骤/","excerpt":"算法可以说是解决问题的步骤。按常理来说学习算法要先掌握一定的数据结构。但因为数组也是一大数据结构，而且也是非常常用的东西，所以在最初，做一些用数组解决的问题（其实java里的数据结构也都是基于数组和类来实现各种数据结构）。","text":"算法可以说是解决问题的步骤。按常理来说学习算法要先掌握一定的数据结构。但因为数组也是一大数据结构，而且也是非常常用的东西，所以在最初，做一些用数组解决的问题（其实java里的数据结构也都是基于数组和类来实现各种数据结构）。 比如一维数组里：计算两个数组的交集，用数组实现约瑟夫环等等；二维数组里（平面坐标初级）：扫雷，边缘检测问题，生命游戏等等。之后进行对数据结构的掌握，会了常用数据结构之后，就可以进行深入的算法研究了。所以这里的建议的顺序是：熟习数组相关操作熟习字符串相关操作认识基础数据结构：线性表、顺序表、链表、栈、队列、树、哈希表、图等。并且自己实现以上数据结构掌握使用提供的数据结构API。排序算法、查找算法。四个基本算法思想：穷举，递推，递归，概率。数学问题，数论问题，数据结构问题，几何问题，字符串问题，大数运算问题。五大常用算法：分治、动态规划（DP），贪心，回溯，分支界定。多看算法题和算法书。 详细内容注：这里都是用java语言作为例子解答代码进行讲解，同时附带的也都是java的api使用说明，但其实算法对语言依赖性不大，重要的是思想。本文提供给大家一个学习方案作为参考。 数组内容：熟习数组的常用操作，可以做一些基础题，可以上leetcode或者别的算法题网站，刷掉初级算法题库里的数组10几个题目，这样对一维和二维数组的掌握灵活度就比较高了。一个比较典型的二维数组逻辑题目：旋转二维数组：给定一个n×n的二维矩阵表示一个图像，输出将图像旋转90度的样子。（不要用另一个矩阵来旋转）题目具体内容点击标题可以进去查看。其他数组例题：两个数组的交集，数组实现约瑟夫环，简易扫雷，生命游戏等等。其他数组的操作大家可以自行去看看别的题，锻炼一下数组的运用思想。 字符串内容：字符串的操作，比如回文串判定、字符串翻转等等。同样建议上题库做一些相应练习。在java里对应的API：string，stringbuilder，stringbuffer。 数据结构此章内容具体参照：java数据结构和他的API内容：这一部分需要自己先去学习一遍数据结构，然后自己写出来。掌握之后，再去查看api文档，最后学会如何使用api里的数据结构写算法，下面介绍的主要是api的对应方式。1、基础数组、线性表：（1）数组：API：Arrays。（2）线性表：API：ArrayList。2、链表：链表是以节点类为基础的，每个节点类有一个成员变量是下一个节点。API：LinkedList。3、集合（java）：API：Collections。这个接口提供了很多常用方法，具体如何使用可以参照帮助文档。4、向量：（可增长数组）API：Vector接口提供方法与数组类似，具体查看API帮助手册。5、栈：自己先基于数组去实现。API：Stack接口提供查看，移除，压入，查找，判空操作6、队列、双端队列、优先队列：（1）队列：API：Queue。（2）双端队列：API：Deque。（3）优先队列： API：PriorityQueue档。7、哈希表（映射表）：API：（1）Hashmap提供了键—值对应的功能。（2）TreeMap提供了可排序的映射表。8、树：树没有api，可以用上面学过的东西去实现它。9、图：图也是没有api的，用之前学过的结构可以构造。 排序内容：在排序里，需要了解这九大排序算法：1、冒泡排序：每两个交换，每轮吧最大的放后面；2、选择排序：每轮选出最大的放后面；3、插入排序：一个线性表，一开始只有一个元素，加一个排一个；4、希尔排序：5、快速排序：6、堆排序：7、合并排序：8、基数排序：9、计数排序： 查找这个阶段要了解到查找算法在平时的应用，最基础的是直接查找和二分查找，但是有时候在不同场景会有一些优化。1、二分法：对排序好的数组用，Collections提供了此方法2、二分法的各种优化搜索：3、数据结构中的查找：（1）顺序表：同数组，序号或者关键字顺序、二分查找。（2）链表：关键字查找，只能一个个往后找，返回引用。（3）树：树或者二叉树遍历一个个找，二叉搜索树可以根据大小找，原理和二分法一样。平衡二叉树同而搜索树，红黑树效率高。（4）图：深度优先遍历查找。 4个基本算法思想此章节具体参照：4个基本算法思想：穷举、递推、递归、概率内容：这4个基本算法思想是解决基础问题的很实用的方法。这里开始其实就已经是把所有需要的知识准备好了，之后就要开始解题了。1、穷举：暴力破解，n层for循环。枚举每一种可能。2、递推：简单的动态规划，根据递推公式，累加。3、普通递归：化解问题逐渐变小（从n到1）4、概率：使用random数量足够大的时候，得到近似结果。 数学问题，数论问题，数据结构问题，几何问题，字符串问题，大数运算问题：内容：这一块需要了解的是零散问题的应用。每一块我举几个例子，推荐大家还是上刷题网站吧零散的题给刷掉，不推荐直接做各个算法难题，先做这些零散题会对之后系统做算法有一些帮助。以下我诺列一些题目，大家可以自己查查，刷题网站上也有。1、数学问题：罗马数字转换Math函数的应用（自行查看api帮助文档）。保留小数点的操作：例如String.format（“%.2f”,string）2、数据结构问题：约瑟夫环：具体点击这里括号匹配：具体点击这里链表排序、最短路径等等。3、数论问题：素数、完全数为代表的问题。4、几何问题：java里有API：抽象类shape——具体类line2d，Point2d提供了一些集合方法。5、大数运算问题：API：BigInteger，提供加减乘除模，大小比较，转化等运算。6、字符串问题：API：String大致包含这些方法：是否包含，比较（可不考虑大小写），第一次出现索引（前后），两个字符串的某个区域是否相等（regionmatches），replace替换，split（[，]）分割，substring删减，tochararray变成字符数组，tolow/toup，trim忽略前后空白，valueof把别的转换成字符串。 五大常用算法五大算法：分治，回溯，贪心，DP（动态规划），分支界定。内容在这一块是需要重点看看的，前4个是重点，也有非常多的经典例题。这一部分还是比较需要时间的，以下仅仅是介绍，点开链接具有详细的每个算法讲解。 1、分治法首先看一下二分搜索：一串数，取中间的数并且平分两半，如果比中间数大，就去上半部分找，然后再两半……这样查找就是分治思想：把一个问题分解成若干个一样的小块。具体详情：分治算法——五大常用算法之一基本概念：把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题。直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。 2、动态规划法具体详情：动态规划——五大常用算法之一基本概念：动态规划（DP）就是：每走一步，都会根据之前的情况来决定这一步的走向，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。使用动态规划法一般会有一个递推公式（递推就是简单动态规划）。当然，最难找到的也是这个递推公式。 3、贪心算法具体详情：贪心算法——五大常用算法之一基本概念：在对问题求解时，总是做出在当前看来是最好的选择。不从整体最优上加以考虑，所做出的仅是在某种意义上的局部最优解。贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。 4、回溯算法具体详情：回溯算法——五大常用算法之一基本概念： 回溯算法实际上一个类似枚举的搜索尝试过程（排列组合），主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。 许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。 5、分支界定这个算法个人没有仔细研究，可能是因为学的较浅没有经常用到。下面内容做一个参考：基本描述 类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。","categories":[{"name":"算法排序","slug":"算法排序","permalink":"http://yoursite.com/categories/算法排序/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"冒泡排序","slug":"冒泡排序","date":"2019-08-03T06:48:39.000Z","updated":"2019-08-03T06:56:44.086Z","comments":true,"path":"2019/08/03/冒泡排序/","link":"","permalink":"http://yoursite.com/2019/08/03/冒泡排序/","excerpt":"思路分析：在要排序的切片中，对当前还未排好的序列，从前往后对相邻的两个元素依次进行比较和调整，让较大的数往下沉，较小的往上冒。即，每当两相邻的元素比较后发现它们的排序与排序要求相反时，就将它们互换。","text":"思路分析：在要排序的切片中，对当前还未排好的序列，从前往后对相邻的两个元素依次进行比较和调整，让较大的数往下沉，较小的往上冒。即，每当两相邻的元素比较后发现它们的排序与排序要求相反时，就将它们互换。 代码实现1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot;)var sli = []int&#123;1, 43, 54, 62, 21, 66, 32, 78, 36, 76, 39&#125;func bubbleSort(sli []int) []int &#123; len := len(sli) //该层循环控制 需要冒泡的轮数 for i := 1; i &lt; len; i++ &#123; //该层循环用来控制每轮 冒出一个数 需要比较的次数 for j := 0; j &lt; len-1; j++ &#123; if sli[i] &lt; sli[j] &#123; sli[i], sli[j] = sli[j], sli[i] &#125; &#125; &#125; return sli&#125;func main() &#123; res := bubbleSort(sli) fmt.Println(res)&#125;","categories":[{"name":"算法排序","slug":"算法排序","permalink":"http://yoursite.com/categories/算法排序/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"睡眠排序","slug":"睡眠排序","date":"2019-08-03T06:45:49.000Z","updated":"2019-08-03T06:47:24.577Z","comments":true,"path":"2019/08/03/睡眠排序/","link":"","permalink":"http://yoursite.com/2019/08/03/睡眠排序/","excerpt":"顾名思义，睡眠排序通过为待排序的元素启动独立的任务，每个任务按照待排元素的key执行相对应的睡眠时间，然后及时的将序列中的元素收集到一起，达到排序的目的。","text":"顾名思义，睡眠排序通过为待排序的元素启动独立的任务，每个任务按照待排元素的key执行相对应的睡眠时间，然后及时的将序列中的元素收集到一起，达到排序的目的。 代码实现1234567891011121314151617181920212223package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; tab := []int&#123;1, 3, 0, 5&#125; ch := make(chan int) for _, value := range tab &#123; go func(val int) &#123; time.Sleep(time.Duration(val) * 10000000) fmt.Println(val) ch &lt;- val &#125;(value) &#125; for _ = range tab &#123; &lt;-ch &#125;&#125;","categories":[{"name":"算法排序","slug":"算法排序","permalink":"http://yoursite.com/categories/算法排序/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"二叉树","slug":"二叉树","date":"2019-08-02T09:22:54.000Z","updated":"2019-08-02T09:31:49.611Z","comments":true,"path":"2019/08/02/二叉树/","link":"","permalink":"http://yoursite.com/2019/08/02/二叉树/","excerpt":"回顾整理二叉树遍历相关内容。 对于二叉树而言，其遍历有两种方式，一种是深度优先，即先优先向下进行遍历，一种是广度优先，逐层向下遍历。","text":"回顾整理二叉树遍历相关内容。 对于二叉树而言，其遍历有两种方式，一种是深度优先，即先优先向下进行遍历，一种是广度优先，逐层向下遍历。 二叉树结构12345type Tree struct &#123; Val int Left *Tree Right *Tree&#125; 深度优先搜索Deepth-First-Search DFS， 对于深度优先而言，又有三种方式，即前序，中序和后序。前中后序之间的前中后，指的是根结点的位置。 前序递归12345678910func PreOrder(root *Tree) []int &#123; var result []int if root == nil &#123; return result &#125; result = append(result, root.Val) result = append(result, PreOrder(root.Left)...) result = append(result, PreOrder(root.Right)...) return result&#125; 前序非递归123456789101112131415161718192021func PreOrderNonRecursive(root *Tree) []int &#123; var result []int if root == nil &#123; return result &#125; stack := list.New() p := root for p != nil || stack.Len() != 0 &#123; for p != nil &#123; result = append(result, p.Val) stack.PushBack(p) p = p.Left &#125; if stack.Len() != 0 &#123; node := stack.Back() stack.Remove(node) p = node.Value.(*Tree).Right &#125; &#125; return result&#125; 中序递归12345678910func InOrder(root *Tree) []int &#123; var result []int if root == nil &#123; return nil &#125; result = append(result, PreOrder(root.Left)...) result = append(result, root.Val) result = append(result, PreOrder(root.Right)...) return result&#125; 中序非递归123456789101112131415161718192021func InOrderNonRecursive(root *Tree) []int &#123; var result []int if root == nil &#123; return result &#125; stack := list.New() p := root for p != nil || stack.Len() != 0 &#123; for p != nil &#123; stack.PushBack(p) p = p.Left &#125; if stack.Len() != 0 &#123; node := stack.Back() stack.Remove(node) result = append(result, node.Value.(*Tree).Val) p = node.Value.(*Tree).Right &#125; &#125; return result&#125; 后序递归12345678910func PostOrder(root *Tree) []int &#123; var result []int if root == nil &#123; return nil &#125; result = append(result, PreOrder(root.Left)...) result = append(result, PreOrder(root.Right)...) result = append(result, root.Val) return result&#125; 后序非递归1234567891011121314151617181920212223242526func PostOrderNonRecursive(root *Tree) []int &#123; var result []int if root == nil &#123; return result &#125; stack := list.New() p := root lastVisit := new(Tree) for p != nil || stack.Len() != 0 &#123; for p != nil &#123; stack.PushBack(p) p = p.Left &#125; if stack.Len() != 0 &#123; node := stack.Back() if node.Value.(*Tree).Right != nil &amp;&amp; lastVisit != node.Value.(*Tree).Right &#123; p = node.Value.(*Tree).Right continue &#125; result = append(result, node.Value.(*Tree).Val) stack.Remove(node) lastVisit = node.Value.(*Tree) &#125; &#125; return result&#125; 广度优先搜索Breadth-First-Search BFS 或者说是 Level Traversal，对于广度优先而言，其基于队列的数据结构，可以很简单的实现出来 1234567891011121314151617181920func LevelTraversal(root *Tree) []int &#123; var result []int if root == nil &#123; return result &#125; queue := list.New() queue.PushBack(root) for queue.Len() != 0 &#123; node := queue.Front() nTree := node.Value.(*Tree) queue.Remove(node) if nTree == nil &#123; continue &#125; result = append(result, nTree.Val) queue.PushBack(nTree.Left) queue.PushBack(nTree.Right) &#125; return result&#125; 需要注意在for循环里，不能直接用 node.Value.(*Tree) == nil 来判断，因为interface特性，会认为其不为 nil，哪怕nTree为nil。 详细内容，可以参考 go interface机制，这里侧重算法，不再细讲。总结 二叉树遍历分为两种，一种是深度优先，一种是广度优先 深度优先分为前，中，后序三种实现方式 深度优先可以使用递归和非递归两种方式实现 深度优先主要借助栈来实现 广度优先主要借助队列来实现","categories":[{"name":"算法排序","slug":"算法排序","permalink":"http://yoursite.com/categories/算法排序/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"插入排序","slug":"插入排序","date":"2019-08-02T09:20:28.000Z","updated":"2019-08-02T09:22:02.587Z","comments":true,"path":"2019/08/02/插入排序/","link":"","permalink":"http://yoursite.com/2019/08/02/插入排序/","excerpt":"思路分析：在要排序的一切片中，假设前面的元素已经是排好顺序的，现在要把第n个元素插到前面的有序切片中，使得这n个元素也是排好顺序的。如此反复循环，直到全部排好顺序。","text":"思路分析：在要排序的一切片中，假设前面的元素已经是排好顺序的，现在要把第n个元素插到前面的有序切片中，使得这n个元素也是排好顺序的。如此反复循环，直到全部排好顺序。 代码实现123456789101112131415161718192021222324252627282930package mainimport ( &quot;fmt&quot;)var sli = []int&#123;1, 43, 54, 62, 21, 66, 32, 78, 36, 76, 39&#125;func insertSort(sli []int) []int &#123; len := len(sli) for i := 0; i &lt; len; i++ &#123; tmp := sli[i] //内层循环控制，比较并插入 for j := i - 1; j &gt;= 0; j-- &#123; if tmp &lt; sli[j] &#123; //发现插入的元素要小，交换位置，将后边的元素与前面的元素互换 sli[j+1], sli[j] = sli[j], tmp &#125; else &#123; //如果碰到不需要移动的元素，则前面的就不需要再次比较了。 break &#125; &#125; &#125; return sli&#125;func main() &#123; res := insertSort(sli) fmt.Println(res)&#125;","categories":[{"name":"算法排序","slug":"算法排序","permalink":"http://yoursite.com/categories/算法排序/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"选择排序","slug":"选择排序","date":"2019-08-02T06:04:30.000Z","updated":"2019-08-02T07:19:58.119Z","comments":true,"path":"2019/08/02/选择排序/","link":"","permalink":"http://yoursite.com/2019/08/02/选择排序/","excerpt":"思路分析：在要排序的切片中，选出最小的一个元素与第一个位置的元素交换。然后在剩下的元素当中再找最小的与第二个位置的元素交换，如此循环到倒数第二个元素和最后一个元素比较为止。","text":"思路分析：在要排序的切片中，选出最小的一个元素与第一个位置的元素交换。然后在剩下的元素当中再找最小的与第二个位置的元素交换，如此循环到倒数第二个元素和最后一个元素比较为止。 代码实现123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;fmt&quot;)var sli = []int&#123;1, 43, 54, 62, 21, 66, 32, 78, 36, 76, 39&#125;func selectSort(sli []int) []int &#123; //双重循环完成，外层控制轮数，内层控制比较次数 len := len(sli) for i := 0; i &lt; len-1; i++ &#123; //先假设最小的值的位置 k := i for j := i + 1; j &lt; len; j++ &#123; //sli[k] 是当前已知的最小值 if sli[k] &gt; sli[j] &#123; //比较，发现更小的,记录下最小值的位置；并且在下次比较时采用已知的最小值进行比较。 k = j &#125; &#125; //已经确定了当前的最小值的位置，保存到 k 中。如果发现最小值的位置与当前假设的位置 i 不同，则位置互换即可。 if k != i &#123; sli[k], sli[i] = sli[i], sli[k] &#125; &#125; return sli&#125;func main() &#123; res := selectSort(sli) fmt.Println(res)&#125;","categories":[{"name":"算法排序","slug":"算法排序","permalink":"http://yoursite.com/categories/算法排序/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"快速排序","slug":"快速排序","date":"2019-08-02T05:51:39.000Z","updated":"2019-08-02T09:22:06.744Z","comments":true,"path":"2019/08/02/快速排序/","link":"","permalink":"http://yoursite.com/2019/08/02/快速排序/","excerpt":"思路分析：选择一个基准元素，通常选择第一个元素或者最后一个元素。通过一趟扫描，将待排序列分成两部分，一部分比基准元素小，一部分大于等于基准元素。此时基准元素在其排好序后的正确位置，然后再用同样的方法递归地排序划分的两部分。","text":"思路分析：选择一个基准元素，通常选择第一个元素或者最后一个元素。通过一趟扫描，将待排序列分成两部分，一部分比基准元素小，一部分大于等于基准元素。此时基准元素在其排好序后的正确位置，然后再用同样的方法递归地排序划分的两部分。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( &quot;fmt&quot;)var sli = []int&#123;1, 43, 54, 62, 21, 66, 32, 78, 36, 76, 39&#125;func quickSort(sli []int) []int &#123; //先判断是否需要继续进行 len := len(sli) if len &lt;= 1 &#123; return sli &#125; //选择第一个元素作为基准 base_num := sli[0] //遍历除了标尺外的所有元素，按照大小关系放入左右两个切片内 //初始化左右两个切片 left_sli := []int&#123;&#125; //小于基准的 right_sli := []int&#123;&#125; //小于基准的 for i := 1; i &lt; len; i++ &#123; if base_num &gt; sli[i] &#123; //放入左边切片 left_sli = append(left_sli, sli[i]) &#125; else &#123; //放入右边切片 right_sli = append(right_sli, sli[i]) &#125; &#125; //再分别对左边和右边的切片进行相同的排序处理方式递归调用这个函数 left_sli = quickSort(left_sli) right_sli = quickSort(right_sli) //合并 left_sli = append(left_sli, base_num) return append(left_sli, right_sli...)&#125;func main() &#123; res := quickSort(sli) fmt.Println(res)&#125;","categories":[{"name":"算法排序","slug":"算法排序","permalink":"http://yoursite.com/categories/算法排序/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"更新","slug":"更新blog","date":"2019-08-02T03:37:17.098Z","updated":"2019-08-02T06:30:47.262Z","comments":true,"path":"2019/08/02/更新blog/","link":"","permalink":"http://yoursite.com/2019/08/02/更新blog/","excerpt":"博客内容更新","text":"博客内容更新 新建文章1$ hexo new \"My New Post\" 运行1$ hexo server 或 $hexo s 清空资源文件1$ hexo clean 重新生成资源文件1$ hexo generate 或 $ hexo g 发布文章到github.io1$ hexo deploy 或 hexo d","categories":[],"tags":[]}]}