{"meta":{"title":"Ywnline","subtitle":null,"description":"http://blog.yuewei.fun","author":"Ywnline","url":"http://blog.yuewei.fun","root":"/"},"pages":[{"title":"categories","date":"2019-08-02T07:34:41.000Z","updated":"2019-08-06T06:03:12.170Z","comments":true,"path":"categories/index.html","permalink":"http://blog.yuewei.fun/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-02T07:35:29.000Z","updated":"2019-08-06T06:03:14.576Z","comments":true,"path":"tags/index.html","permalink":"http://blog.yuewei.fun/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"GOLANG测试","slug":"GOLANG测试","date":"2019-08-20T02:19:46.000Z","updated":"2019-08-20T08:56:52.688Z","comments":true,"path":"2019/08/20/GOLANG测试/","link":"","permalink":"http://blog.yuewei.fun/2019/08/20/GOLANG测试/","excerpt":"testing - 单元测试testing 为GO语言package 提供自动化测试的支持 1func TestXxx(*testing.T)","text":"testing - 单元测试testing 为GO语言package 提供自动化测试的支持 1func TestXxx(*testing.T) 示例要测试的代码：123456func Fib(n int) int &#123; if n &lt; 2 &#123; return n &#125; return Fib(n-1) + Fib(n-1)&#125; 测试代码：12345678910func TestFib(t *testing.T) &#123; var ( in = 7 expected = 13 ) actual := Fib(in) if actual != expected &#123; t.Errorf(&quot;Fib(%d) = %d; expected %d&quot;, in, actual, expected) &#125;&#125; 12345$ go test .--- FAIL: TestSum (0.00s) t_test.go:16: Fib(10) = 64; expected 13FAILFAIL chapter09/testing 0.009s Table-Driven Testcase 覆盖123456789101112131415161718192021func TestFib(t *testing.T) &#123; var fibTests = []struct &#123; in int // input expected int // expected result &#125;&#123; &#123;1, 1&#125;, &#123;2, 1&#125;, &#123;3, 2&#125;, &#123;4, 3&#125;, &#123;5, 5&#125;, &#123;6, 8&#125;, &#123;7, 13&#125;, &#125; for _, tt := range fibTests &#123; actual := Fib(tt.in) if actual != tt.expected &#123; t.Errorf(&quot;Fib(%d) = %d; expected %d&quot;, tt.in, actual, tt.expected) &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"数据结构","slug":"数据结构","date":"2019-08-09T01:37:33.000Z","updated":"2019-08-09T02:19:29.081Z","comments":true,"path":"2019/08/09/数据结构/","link":"","permalink":"http://blog.yuewei.fun/2019/08/09/数据结构/","excerpt":"概念数据结构就是研究数据的逻辑结构和物理结构以及它们之间相互关系，并对这种结构定义相应的运算，而且确保经过这些运算后所得到的新结构仍然是原来的结构类型。","text":"概念数据结构就是研究数据的逻辑结构和物理结构以及它们之间相互关系，并对这种结构定义相应的运算，而且确保经过这些运算后所得到的新结构仍然是原来的结构类型。 数据：所有能被输入到计算机中，且能被计算机处理的符号的集合。是计算机操作的对象的总称。 数据元素：数据（集合）中的一个“个体”，数据及结构中讨论的基本单位 数据项：数据的不可分割的最小单位。一个数据元素可由若干个数据项组成。 数据类型：在一种程序设计语言中，变量所具有的数据种类。整型、字符型等等 逻辑结构：数据之间的相互关系。 集合 结构中的数据元素除了同属于一种类型外，别无其它关系。 线性结构 数据元素之间一对一的关系 树形结构 数据元素之间一对多的关系 图状结构或网状结构 结构中的数据元素之间存在多对多的关系 物理结构/存储结构：数据在计算机中的表示。物理结构是描述数据具体在内存中的存储（如：顺序结构、链式结构、索引结构、哈希结构）等 在数据结构中,从逻辑上可以将其分为线性结构和非线性结构 数据结构的基本操作的设置的最重要的准则 实现应用程序与存储结构的独立。实现应用程序是“逻辑结构” 存储的是“物理结构”。逻辑结构主要是对该结构操作的设定物理结构是描述数据具体在内存中的 顺序结构、链式结构、索引结构、希哈结构 顺序存储结构中，线性表的逻辑顺序和物理顺序总是一致的。但在链式存储结构中，线性表的逻辑顺序和物理顺序一般是不同的。 算法五个特性： 有穷性、确定性、可行性、输入、输出 算法设计要求：正确性、可读性、健壮性、高效率与低存储量需求。 算法的描述有伪程序、流程图、N-S结构图等。E-R图是实体联系模型，不是程序的描述方式。 设计算法在执行时间时需要考虑：算法选用的规模、问题的规模 时间复杂度：算法的执行时间与原操作执行次数之和成正比。时间复杂度有小到大：O(1)、O(logn)、O(n)、O(nlogn)、O(n2)、O(n3)。幂次时间复杂度有小到大O(2n)、O(n!)、O(nn) 空间复杂度：若输入数据所占空间只取决于问题本身，和算法无关，则只需要分析除输入和程序之外的辅助变量所占额外空间。 线性表 对于同一个线性表，其每一个数据元素的值虽然不同，但必须具有相同的数据类型 线性表是一种典型的线性结构。头结点无前驱有一个后继，尾节点无后继有一个前驱。链表只能顺序查找，定位一个元素的时间为O(N)，删除一个元素的时间为O(1) 线性表的顺序存储结构把线性表的结点按逻辑顺序依次存放在一组地址连续的存储单元里。用这种方法存储的线性表简称顺序表。是一种随机存取的存储结构。顺序存储指内存地址是一块的，随机存取指访问时可以按下标随机访问，存储和存取是不一样的。如果是存储，则是指按顺序的，如果是存取，则是可以随机的，可以利用元素下标进行。数组比线性表速度更快的是：原地逆序、返回中间节点、选择随机节点。 便于线性表的构造和任意元素的访问 插入：插入新结点，之后结点后移。平均时间复杂度:O(n) 删除：删除节点，之后结点前移。平均时间复杂度:O(n) 线性链表 单链表中每个结点的存储地址是存放在其前趋结点next域中，而开始结点无前趋，故应设头指针head指向开始结点。同时，由于最后一个结点无后继，故结点的指针域为空，即NULL。头插法建表(逆序)、尾插法建表(顺序)。增加头结点的目的是算法实现上的方便，但增大了内存开销。 查找：只能从链表的头指针出发，顺链域next逐个结点往下搜索，直到搜索到第i个结点为止。因此，链表不是随机存取结构。 插入：先找到表的第i-1的存储位置，然后插入。新结点先连后继，再连前驱。 删除：首先找到ai-1的存储位置p。然后令p–&gt;next指向ai的直接后继结点，即把ai从链上摘下。最后释放结点ai的空间.r=p-&gt;next;p-&gt;next=r-&gt;next;delete r。判断一个单向链表中是否存在环的最佳方法是快慢指针。 静态链表：用一维数组来实现线性链表，这种用一维数组表示的线性链表，称为静态链表。静态：体现在表的容量是一定的。（数组的大小）；链表：插入与删除同前面所述的动态链表方法相同。静态链表中指针表示的是下一元素在数组中的位置。静态链表是用数组实现的，是顺序的存储结构，在物理地址上是连续的，而且需要预先分配大小。动态链表是用申请内存函数（C是malloc,C++是new）动态申请内存的，所以在链表的长度上没有限制。动态链表因为是动态申请内存的，所以每个节点的物理地址不连续，要通过指针来顺序访问。静态链表在插入、删除时也是通过修改指针域来实现的，与动态链表没有什么分别 循环链表：是一种头尾相接的链表。其特点是无须增加存储量，仅对表的链接方式稍作改变，即可使得表处理更加方便灵活。在单链表中，将终端结点的指针域NULL改为指向表头结点的或开始结点，就得到了单链形式的循环链表，并简单称为单循环链表。由于循环链表中没有NULL指针，故涉及遍历操作时，其终止条件就不再像非循环链表那样判断p或p—&gt;next是否为空，而是判断它们是否等于某一指定指针，如头指针或尾指针等。 双向链表:在单链表的每个结点里再增加一个指向其直接前趋的指针域prior。这样就形成的链表中有两个方向不同的链。双链表一般由头指针唯一确定的，将头结点和尾结点链接起来构成循环链表，并称之为双向链表。设指针p指向某一结点，则双向链表结构的对称性可用下式描述：p—&gt;prior—&gt;next=p=p—&gt;next—&gt;prior。从两个方向搜索双链表，比从一个方向搜索双链表的方差要小。 插入：先搞定插入节点的前驱和后继，再搞定后结点的前驱，最后搞定前结点的后继。 在有序双向链表中定位删除一个元素的平均时间复杂度为O(n) 可以直接删除当前指针所指向的节点。而不需要像单向链表中，删除一个元素必须找到其前驱。因此在插入数据时，单向链表和双向链表操作复杂度相同，而删除数据时，双向链表的性能优于单向链表 线性表的抽象数据类型描述 线性表的置空操作clear()：将一个已经存在的线性表置为空表。 线性表判空操作isEmpty()：判断线性表是否为空，若为空，则返回true；否则，返回为false。 求线性表的长度操作length()：求线性表中的数据元素的个数并返回其值。 取元素操作get(i)：读取并返回线性表中的第i个数据元素的值。其中i的取值范围为0≤i≤length()-1。 插入操作insert(i,x)：在线性表的第i个数据元素之前插入一个值为x的数据元素。其中i的取值范围为0≤i≤length()。当i=0时，在表头插入x；当i=length()时，在表尾插入x。 删除操作remove(i)：删除并返回线性表中第i个数据元素。其中i的取值范围为0≤i≤length()-1。 查找操作indexOf(x)：返回线性表中首次出现的指定的数据元素的位序号，若线性表中不包含此数据元素，则返回-1。 线性表的抽线数据类型用Golang接口描述如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package mainimport ( &quot;errors&quot; &quot;fmt&quot;)const MAX_LENGTH = 20 // 常量定义线性表最大长度// 定义一个线性表顺序存储结构体type LineList struct &#123; MaxLength int Length int LineListContent []interface&#123;&#125;&#125;// 初始化一个线性表func InitLineList () *LineList&#123; return &amp;LineList&#123;MaxLength:MAX_LENGTH, LineListContent:make([]interface&#123;&#125;,0,MAX_LENGTH)&#125;&#125;// 判断当前线性表是否为空func (l LineList) IsEmpty() bool &#123; if l.Length == 0&#123; return true &#125; return false&#125;// 判断当前线性表是否满了func (l LineList) IsFull() bool&#123; if l.Length == l.MaxLength&#123; return true &#125; return false&#125;// 判断索引是否越界，越界返回ｔｒｕｅfunc (l LineList) indexOver(i int) bool&#123; if i &lt; 1 || i &gt;l.Length&#123; return true &#125; return false&#125;// 获取一个ｎｏｄｅ数据func (l LineList) getData(i int )(interface&#123;&#125;,error)&#123; if ok:= l.indexOver(i); ok&#123; return &quot;&quot;,errors.New(&quot;查找的索引不在线性表范围内&quot;) &#125; return l.LineListContent[i+1],nil&#125;// 任意位置删除一个ｎｏｄｅ数据func (l *LineList) Delete(i int)(interface&#123;&#125;,error)&#123; if ok:= l.indexOver(i); ok&#123; return &quot;&quot;,errors.New(&quot;删除的索引不在线性表范围内&quot;) &#125; if ok:=l.IsEmpty();ok&#123; return &quot;&quot;,errors.New(&quot;空表没有可删除的数据&quot;) &#125; deleteData := l.LineListContent[i-1] for j:=i-1; j&lt;l.Length-1;j++&#123; l.LineListContent[j] = l.LineListContent[j+1] fmt.Println(j,&quot;个&quot;,l.LineListContent[j]) &#125; l.LineListContent = l.LineListContent[:l.Length-1] // 留了最后一个在，需要切除 l.Length -- return deleteData,nil&#125;//末尾 ｐｏｐ 一个数据func (l *LineList) Pop()(interface&#123;&#125;,error)&#123; if ok:= l.IsEmpty();ok&#123; return &quot;&quot;,errors.New(&quot;空表，无法删除任何数据&quot;) &#125; temp := l.LineListContent[l.Length-1] l.LineListContent = l.LineListContent[:l.Length-1] l.Length -- return temp,nil&#125;// 末尾 Append 一个数据func (l *LineList) Append(data interface&#123;&#125;)(bool,error)&#123; if ok:= l.IsFull(); ok&#123; return false,errors.New(&quot;线性表已满，无法添加数据&quot;) &#125; l.LineListContent = append(l.LineListContent, data) l.Length ++ return true,nil&#125;// 任意位置 ｉｎｓｅｒｔ 一个数据func (l *LineList) Insert(i int,data interface&#123;&#125;)(bool,error)&#123; if ok:= l.IsFull(); ok&#123; return false,errors.New(&quot;线性表已满，无法添加数据&quot;) &#125; if ok:= l.indexOver(i);ok&#123; return false,errors.New(&quot;插入点越界&quot;) &#125; l.Append(&quot;&quot;) // 增加一个空数据，防止下面访问越界 for j:=l.Length-1;j&gt;i-1;j--&#123; //从后往前赋值，新增一个空ｎｏｄｅ，然后把数据一个个后移，直到插入的位置 //知道线性表从１开始，而切片是从０开始的 l.LineListContent[j] = l.LineListContent[j-1] &#125; l.LineListContent[i-1] = data return true,nil&#125;func main()&#123; ls := InitLineList() ls.Append(11) fmt.Println(ls.LineListContent) //[11] fmt.Println(ls.Length) // 1 ls.Insert(3,&quot;gac&quot;) ls.Insert(1,&quot;gac&quot;) fmt.Println(ls.LineListContent) //[gac 11] fmt.Println(ls.Length) //2 ls.Delete(2) fmt.Println(ls.LineListContent) //[gac] fmt.Println(ls.Length) // 1 cd,err0 := ls.Pop() if err0==nil&#123; fmt.Println(cd) // gac &#125; fmt.Println(ls.LineListContent) //[] fmt.Println(ls.Length) // 0&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://blog.yuewei.fun/tags/数据结构/"}]},{"title":"Redis学习","slug":"Redis学习","date":"2019-08-08T09:33:24.000Z","updated":"2019-09-06T09:35:02.738Z","comments":true,"path":"2019/08/08/Redis学习/","link":"","permalink":"http://blog.yuewei.fun/2019/08/08/Redis学习/","excerpt":"准备Redis安装不在赘述、各种环境各种版本网上随便一搜都可以 启动1redis-server redis.windows.conf Redis 命令行客户端1redis-cli -h IP -p port","text":"准备Redis安装不在赘述、各种环境各种版本网上随便一搜都可以 启动1redis-server redis.windows.conf Redis 命令行客户端1redis-cli -h IP -p port 入门常用命令 获得符合规则的键名列表 1KEYS pattern 判断一个键是否存在 1EXISTS key 删除键 1DEL key [key ....] 获取键值得数据类型 1TYPE key 字符串类型Redis 中最基本的数据类型，他能存储任何形式的字符串，最大容量512M 命令 赋值与取值 12SET key valueGET key 递增数字 1INCR key 增加指定的整数 1INCRBY key increment 减少指定的整数 12DECR keyDECRBY key decrement 增加指定浮点数 1INCRBYFLOAT key increment 向尾部追加值 1APPEND key value 获取字符串长度 1STRLEN key 同时获得/设置多个键值 12MGET key [key ...]MSET key value [key value ...] 位操作 1234GETBIT key offsetSETBIT key offset value BITCOUNT key [start] [end]BITOP operation destkey key [key ...] 实践命名（推荐）：对象类型：对象ID：对象属性（例：user:1:friends） 使用示例123456789101112131415161718192021222324252627282930redis 127.0.0.1:6379&gt; set baidu http://www.baiduOKredis 127.0.0.1:6379&gt; append baidu .com(integer) 20redis 127.0.0.1:6379&gt; get baidu&quot;http://www.baidu.com&quot;redis 127.0.0.1:6379&gt; set visitors 0OKredis 127.0.0.1:6379&gt; incr visitors(integer) 1redis 127.0.0.1:6379&gt; incr visitors(integer) 2redis 127.0.0.1:6379&gt; get visitors&quot;2&quot;redis 127.0.0.1:6379&gt; incrby visitors 100(integer) 102redis 127.0.0.1:6379&gt; get visitors&quot;102&quot;redis 127.0.0.1:6379&gt; type baidustringredis 127.0.0.1:6379&gt; type visitorsstringredis 127.0.0.1:6379&gt; ttl baidu(integer) -1redis 127.0.0.1:6379&gt; rename baidu baidu-siteOKredis 127.0.0.1:6379&gt; get baidu(nil)redis 127.0.0.1:6379&gt; get baidu-site&quot;http://www.baidu.com&quot; 散列类型（字典，哈希表）Redis采用字典结构以键值对的形式存储数据的，散列类型的键值也是一种字典结构，其存储了字段和字段值得映射，一个散列类型键可以包含2的32次-1个字段 命令 赋值与取值 12345HSET key field value HGET key field HMSET key field value [field value ...]HMGET key field [field ...]HGETALL key HSET 不区分插入和更新，修改数据是不必判断字段是否存在 判断字段是否存在 1HEXISTS key field 当字段不存在时赋值 1HSETNX key field value 增加数字 1HINCRBY key field increment 删除字段 1HDEL key field [field ...] 只取字段名或字段值 12HKEYS keyHVALS key 获得字段数量 1HLEN key 使用示例123456789101112131415161718192021127.0.0.1:6379&gt; hset person name jack(integer) 1127.0.0.1:6379&gt; hset person age 20(integer) 1127.0.0.1:6379&gt; hset person sex famale(integer) 1127.0.0.1:6379&gt; hgetall person1) &quot;name&quot;2) &quot;jack&quot;3) &quot;age&quot;4) &quot;20&quot;5) &quot;sex&quot;6) &quot;famale&quot;127.0.0.1:6379&gt; hkeys person1) &quot;name&quot;2) &quot;age&quot;3) &quot;sex&quot;127.0.0.1:6379&gt; hvals person1) &quot;jack&quot;2) &quot;20&quot;3) &quot;famale&quot; 列表类型可以存储一个有序的字符串列表，常用的操作是向列表良多添加元素，或者获得列表中的某一段 命令 向列表两端添加元素 12LPUSH key value [value ...]RPUSH key value [value ...] 从列表两端弹出元素 12LPOP key RPOP key 获取列表中元素的个数 1LLEN key 获得列表片段 1LRANGE key start stop 删除列表中指定的值 1LREM key count value 获得/设置指定索引的元素值 12LINDEX key indexLSET key index value 只保留列表指定片段 1LTRIM key start end 向列表中插入元素 1LINSERT key BEFORE|AETER pivot value 将元素从一个列表转移到另一个列表 1RPOPLPUSH source destination 使用示例123456789101112131415161718redis 127.0.0.1:6379&gt; lpush list1 redis(integer) 1redis 127.0.0.1:6379&gt; lpush list1 hello(integer) 2redis 127.0.0.1:6379&gt; rpush list1 world(integer) 3redis 127.0.0.1:6379&gt; llen list1(integer) 3redis 127.0.0.1:6379&gt; lrange list1 0 31) &quot;hello&quot;2) &quot;redis&quot;3) &quot;world&quot;redis 127.0.0.1:6379&gt; lpop list1&quot;hello&quot;redis 127.0.0.1:6379&gt; rpop list1&quot;world&quot;redis 127.0.0.1:6379&gt; lrange list1 0 31) &quot;redis&quot; 集合可以理解为一堆值不重复的列表，类似数学领域中的集合概念，且Redis也提供了针对集合的求交集、并集、差集等操作。set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。 命令 添加一个或者多个元素到集合(set)里 12SADDSADD key member [member ...] 获取集合里面的元素数量 12SACRDSCARD key 获得队列不存在的元素 12SDIFFSDIFF key [key ...] 获得队列不存在的元素，并存储在一个关键的结果集 12SDIFFSTORESDIFFSTORE destination key [key ...] 获得两个集合的交集 12SINTERSINTER key [key ...] 获得两个集合的交集，并存储在一个集合中 12SINTERSTORESINTERSTORE destination key [key ...] 确定一个给定的值是一个集合的成员 12SISMEMBERSISMEMBER key member 获取集合里面的所有key 12SMEMBERSSMEMBERS key 移动集合里面的一个key到另一个集合 12SMOVESMOVE source destination member 获取并删除一个集合里面的元素 12SPOPSPOP key [count] 从集合里面随机获取一个元素 12SRANDMEMBERSRANDMEMBER key [count] 从集合里删除一个或多个元素，不存在的元素会被忽略 12SREMSREM key member [member ...] 添加多个set元素 12SUNIONSUNION key [key ...] 合并set元素，并将结果存入新的set里面 12SUNIONSTORESUNIONSTORE destination key [key ...] 迭代set里面的元素 12SSCANSSCAN key cursor [MATCH pattern] [COUNT count] 有序集合一个有序集合的每个成员带有分数，用于进行排序。Redis有序集合添加、删除和测试的时间复杂度均为O(1)(固定时间，无论里面包含的元素集合的数量)Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。 使用场景用户的积分排行榜需求就可以通过有序集合实现。还有上面介绍的使用List实现轻量级的消息队列，其实也可以通过Sorted Set实现有优先级或按权重的队列。 命令 添加一个或多个成员到有序集合，或者如果它已经存在更新其分数 12ZADDZADD key score1 member1 [score2 member2] 得到的有序集合成员的数量 12ZCARDZCARD key 计算一个有序集合成员与给定值范围内的分数 12ZCOUNTZCOUNT key min max 在有序集合增加成员的分数 12ZINCRBYZINCRBY key increment member 多重交叉排序集合，并存储生成一个新的键有序集合。 12ZINTERSTOREZINTERSTORE destination numkeys key [key ...] 计算一个给定的字典范围之间的有序集合成员的数量 12ZLEXCOUNTZLEXCOUNT key min max 由索引返回一个成员范围的有序集合（从低到高） 12ZRANGEZRANGE key start stop [WITHSCORES] 返回一个成员范围的有序集合（由字典范围） 12ZRANGEBYLEXZRANGEBYLEX key min max [LIMIT offset count] 返回有序集key中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员，有序集成员按 score 值递增(从小到大)次序排列 12ZRANGEBYSCOREZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] 确定成员的索引中有序集合 12ZRANKZRANK key member 从有序集合中删除一个或多个成员，不存在的成员将被忽略 12ZREMZREM key member [member ...] 删除所有成员在给定的字典范围之间的有序集合 12ZREMRANGEBYLEXZREMRANGEBYLEX key min max 在给定的索引之内删除所有成员的有序集合 12ZREMRANGEBYRANKZREMRANGEBYRANK key start stop 在给定的分数之内删除所有成员的有序集合 12ZREMRANGEBYSCOREZREMRANGEBYSCORE key min max 返回一个成员范围的有序集合，通过索引，以分数排序，从高分到低分 12ZREVRANGEZREVRANGE key start stop [WITHSCORES] 返回一个成员范围的有序集合，以socre排序从高到低 12ZREVRANGEBYSCOREZREVRANGEBYSCORE key max min [WITHSCORES] 确定一个有序集合成员的索引，以分数排序，从高分到低分 12ZREVRANKZREVRANK key member 获取给定成员相关联的分数在一个有序集合 12ZSCOREZSCORE key member 添加多个集排序，所得排序集合存储在一个新的键 12ZUNIONSTOREZUNIONSTORE destination numkeys key [key ...] 增量迭代排序元素集和相关的分数 12ZSCANZSCAN key cursor [MATCH pattern] [COUNT count] 使用示例12345678910111213141516171819202122redis 127.0.0.1:6379&gt; zadd dbs 100 redis(integer) 1redis 127.0.0.1:6379&gt; zadd dbs 98 memcached(integer) 1redis 127.0.0.1:6379&gt; zadd dbs 99 mongodb(integer) 1redis 127.0.0.1:6379&gt; zadd dbs 99 leveldb(integer) 1redis 127.0.0.1:6379&gt; zcard dbs(integer) 4redis 127.0.0.1:6379&gt; zcount dbs 10 99(integer) 3redis 127.0.0.1:6379&gt; zrank dbs leveldb(integer) 1redis 127.0.0.1:6379&gt; zrank dbs other(nil)redis 127.0.0.1:6379&gt; zrangebyscore dbs 98 1001) &quot;memcached&quot;2) &quot;leveldb&quot;3) &quot;mongodb&quot;4) &quot;redis&quot;Reference 事务概述：Redis中的事务十一组命令的集合 将属于一个事物的命令先送给Redis，然后再让Redis一次执行这些命令 使用示例123456789127.0.0.1:6789&gt; MULTIOK127.0.0.1:6789&gt; SADD &quot;user:1:following&quot; 2QUEUED127.0.0.1:6789&gt; SADD &quot;user:2:followers&quot; 1QUEUED127.0.0.1:6789&gt; EXEC1) (integer) 02) (integer) 0 错误处理 语法错误：不存在或参数不对 执行EXEC命令后Redis就直接返回错误，正确的命令也不会执行 运行错误:使用不同类型命令 错误命令之前命令不执行 之后命令会执行 Redis 无回滚 watch 命令介绍概述：watch 命令可以监控一个或多个键，一点其中有一个键被修改（或删除），之后的事务就不会执行。监控一直持续到EXEC命令（事务中的命令是在EXEC之后才执行的，所以在MULTI命令后可以修改WATCH监控的键值）示例1234567891011121314127.0.0.1:6789&gt; SET demo 1OK127.0.0.1:6789&gt; watch demoOK127.0.0.1:6789&gt; set demo 2OK127.0.0.1:6789&gt; MULTIOK127.0.0.1:6789&gt; set demo 3QUEUED127.0.0.1:6789&gt; EXEC -(nil)127.0.0.1:6789&gt; get key&quot;2&quot; 过期时间 设置过期时间 12EXPIREEXPIRE key sconds 查看过期时间(不存在返回-2，键没有过期时间-1) 12TTLTTL foo 实现访问频率限制之一示例： 12345678910$isKeyExists = EXISTS rete.limiting:$IPif $isKeyExists is 1 $times = INCR rate.limiting:$IP if $times &gt; 100 print 访问超限 稍后重试else MULTL INCR rate.limiting:$IP EXPIRE $keyName, 60 EXEC实现访问频率限制之二示例： 123456789101112$listLength = L:EN rate.limiting:$IPif $listLength &lt; 10 LPUSH rate.limitingL$IP, now()else $time = LINDEX rate.limiting:$IP, -1 if now() - $time &lt; 60 print 超过限制 else LPUSH rate.limiting:$IP, now() LTRIM rate.limiting:$IP, 0, 9// now() 获得当前Unix时间","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.yuewei.fun/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://blog.yuewei.fun/tags/数据库/"}]},{"title":"策略模式","slug":"策略模式","date":"2018-08-07T08:33:22.000Z","updated":"2019-08-07T09:01:42.119Z","comments":true,"path":"2018/08/07/策略模式/","link":"","permalink":"http://blog.yuewei.fun/2018/08/07/策略模式/","excerpt":"概述策略模式定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户","text":"概述策略模式定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户 使用场景需要有一系列不同的算法，这些算法完成的工作是同样的，只是实现不同，强调以相同的方式调用所有的算法，减少算法类和使用算法类之间的耦合 优势使代码结构清晰，便于维护，简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试 每个算法的修改都不会影响到其他的算法 实际应用场景商场商品价格计算，其中涉及到的有商品的单价，个数，折扣 折扣的策略有： 固定折扣 满减 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546type CashSuper interface &#123; Accept(float64) float64&#125;//CashNormal normal strategytype CashNormal struct&#123;&#125;func (normal CashNormal) Accept(money float64) float64 &#123; return money&#125;//CashRebatetype CashRebate struct &#123; moneyRebate float64&#125;func (re CashRebate) Accept(money float64) float64 &#123; return money * re.moneyRebate&#125;//CashReturntype CashReturn struct &#123; moneyCondition float64 moneyReturn float64&#125;func (re CashReturn) Accept(money float64) float64 &#123; if money &gt;= re.moneyCondition &#123; return money - re.moneyReturn &#125; return money&#125; type CashContext struct &#123; strategy CashSuper&#125;func NewCashContext(acceptType string) (cashFactory CashContext) &#123; switch acceptType &#123; default: fmt.Println(&quot;wrong type&quot;) case &quot;normal&quot;: cashFactory.strategy = CashNormal&#123;&#125; case &quot;0.8rebate&quot;: cashFactory.strategy = CashRebate&#123;moneyRebate: 0.8&#125; case &quot;300return100&quot;: cashFactory.strategy = CashReturn&#123;300, 100&#125; &#125; return&#125;func (cashFactory CashContext) Accept(money float64) float64 &#123; return cashFactory.strategy.Accept(money)&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.yuewei.fun/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.yuewei.fun/tags/设计模式/"}]},{"title":"设计原则","slug":"设计原则","date":"2018-08-07T08:11:02.000Z","updated":"2019-08-07T09:01:36.582Z","comments":true,"path":"2018/08/07/设计原则/","link":"","permalink":"http://blog.yuewei.fun/2018/08/07/设计原则/","excerpt":"设计原则则是设计模式所遵循的规则，设计模式就是实现了这些原则，从而达到了代码复用、增加可维护性的目的。","text":"设计原则则是设计模式所遵循的规则，设计模式就是实现了这些原则，从而达到了代码复用、增加可维护性的目的。 单一职责原则一个类，只有一个引起它变化的原因。应该只有一个职责。 问题由来：类T负责两个不同的职责P1和P2。由于职责P1需要发生改变而需要修改T类，就有可能导致原来运行正常的职责P2功能发生故障。 解决方法：遵循单一职责原则。分别建立新的类来对应相应的职责；这样就能避免修改类时影响到其他的职责； 每一个职责都是变化的一个轴线，如果一个类有一个以上的职责，这些职责就耦合在了一起。这会导致脆弱的设计。当一个职责发生变化时，可能会影响其它的职责。另外，多个职责耦合在一起，会影响复用性。 例：要实现逻辑和界面的分离。 优点：类的复杂性将会降低，可读性将会大大提高，维护性也会提高。 开放封闭原则软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。 对扩展开放 意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。 对修改封闭 意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。 封装变化，是实现开放封闭原则的重要手段，对于经常发生变化的状态一般将其封装为一个抽象。 拒绝滥用抽象，只将经常变化的部分进行抽象，这种经验可以从设计模式的学习与应用中获得。 里氏替换原则子类可以扩展父类的功能，但不能改变父类原有的功能 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 子类中可以增加自己特有的方法 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。 最少知识原则最少知识原则又叫迪米特法则。核心思想是：低耦合、高内聚 一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。也就是说一个软件实体应当尽可能少的与其他实体发生相互作用。这样，当一个模块修改时，就会尽量少的影响其他的模块，扩展会相对容易，这是对软件实体之间通信的限制，它要求限制软件实体之间通信的宽度和深度。 接口隔离原则定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上，否则将会造成接口污染；类A通过接口I依赖类B，类C通过接口I依赖类D，如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现它们不需要的方法； 原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少；就是说，我们要为每个类建立专用的接口，而不要试图去建立一个庞大的接口供所有依赖它的类去调用； 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。 为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 依赖倒置原则核心思想是面向接口编程 问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来完成；这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原则操作；假如修改类A，会给程序带来不必要的风险。 解决方案：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I来间接与类B和类C发生联系，则会降低修改类A的几率； 低层模块尽量都要有抽象类或接口，或者两者都有。 变量的声明类型尽量是抽象类或接口。 使用继承时遵循里氏替换原则。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.yuewei.fun/tags/设计模式/"},{"name":"设计原则","slug":"设计原则","permalink":"http://blog.yuewei.fun/tags/设计原则/"}]},{"title":"简单工厂模式","slug":"设计模式学习-简单工厂模式","date":"2018-08-03T08:25:10.000Z","updated":"2019-08-07T09:01:30.774Z","comments":true,"path":"2018/08/03/设计模式学习-简单工厂模式/","link":"","permalink":"http://blog.yuewei.fun/2018/08/03/设计模式学习-简单工厂模式/","excerpt":"概述工厂模式是对象的生产器，解耦用户对具体的依赖。通过封闭、继承、多态把程序的耦合度降低，使程序更加灵活，容易修改，并易于复用。简单工厂模式中，各种运算方法类实现了运算接口，在业务上如果想添加一种算法方法，只需要增加一个实现接口的类，并且在工厂的类型中添加一个判断。这种设计适合用于业务逻辑并不多的情况，如果业务逻辑非常多，那么工作累就是一个很长的swuth…case结构这时候使用工厂模式会比较合适。","text":"概述工厂模式是对象的生产器，解耦用户对具体的依赖。通过封闭、继承、多态把程序的耦合度降低，使程序更加灵活，容易修改，并易于复用。简单工厂模式中，各种运算方法类实现了运算接口，在业务上如果想添加一种算法方法，只需要增加一个实现接口的类，并且在工厂的类型中添加一个判断。这种设计适合用于业务逻辑并不多的情况，如果业务逻辑非常多，那么工作累就是一个很长的swuth…case结构这时候使用工厂模式会比较合适。 主要类 base - interface concreteA - concrete class A concreteB - concrete class B factory - in: choice; out: base 优势工厂类中包含了必要的逻辑判断，根据客户端的选择条件实例化相应的类，对于客户端来说，去除了与具产品的依赖 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*设计一个计算器*///Operation 操作接口type Operation interface &#123; SetNumber(float64, float64) GetResult() float64&#125;//BaseOperation 基础类type BaseOperation struct &#123; Operation NumberA float64 NumberB float64&#125;func (bo *BaseOperation) SetNumber(numberA, numberB float64) &#123; bo.NumberA = numberA bo.NumberB = numberB&#125;//OperationAdd 加法运算type OperationAdd struct &#123; BaseOperation&#125;func (oa OperationAdd) GetResult() float64 &#123; return oa.NumberA + oa.NumberB&#125;//OperationSub 减法运算类type OperationSub struct &#123; BaseOperation&#125;func (os OperationSub) GetResult() float64 &#123; return os.NumberA - os.NumberB&#125; //OperationFactory 工厂类type OperationFactory struct&#123;&#125;func (of OperationFactory) CreateOperation(oper string) Operation &#123; switch oper &#123; default: return nil case &quot;+&quot;: return new(OperationAdd) case &quot;-&quot;: return new(OperationSub) &#125;&#125;//OperationUsage 工厂操作func OperationUsage() &#123;factory := new(OperationFactory)operation := factory.CreateOperation(&quot;+&quot;)operation.SetNumber(1, 2)fmt.Printf(&quot;this is add operation, 1+2=%v\\n&quot;, operation.GetResult())operation = factory.CreateOperation(&quot;-&quot;)operation.SetNumber(2, 1)fmt.Printf(&quot;this is sub operation, 2-1=%v\\n&quot;, operation.GetResult())&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*设计一个工厂来生产各种厂商的手机其中初始的厂商有小米，苹果，华为*///Phone interfacetype Phone interface &#123; ShowBrand()&#125;//IPhone appletype IPhone struct &#123;&#125;func (phone IPhone) ShowBrand() &#123; fmt.Println(&quot;[Phone Brand]: Apple&quot;)&#125;//HPhone huaweitype HPhone struct &#123;&#125;func (phone HPhone) ShowBrand() &#123; fmt.Println(&quot;[Phone Brand]: Huawei&quot;)&#125;//XPhone xiaomitype XPhone struct &#123;&#125;func (phone XPhone) ShowBrand() &#123; fmt.Println(&quot;[Phone Brand]: Xiaomi&quot;)&#125;type PhoneFactory struct&#123;&#125;func (factory PhoneFactory) CreatePhone(brand string) Phone &#123; switch brand &#123; default: return nil case &quot;HW&quot;: return new(HPhone) case &quot;XM&quot;: return new(XPhone) case &quot;PG&quot;: return new(IPhone) &#125;&#125;func PhoneUsage() &#123; factory := PhoneFactory&#123;&#125; phone := factory.CreatePhone(&quot;HW&quot;) phone.ShowBrand()&#125; 12345678func main() &#123; OperationUsage() PhoneUsage()&#125;result :this is add operation, 1+2=3this is sub operation, 2-1=1[Phone Brand]: Huawei","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.yuewei.fun/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.yuewei.fun/tags/设计模式/"}]},{"title":"常用排序","slug":"排序","date":"2018-08-03T06:48:39.000Z","updated":"2019-08-07T09:02:00.001Z","comments":true,"path":"2018/08/03/排序/","link":"","permalink":"http://blog.yuewei.fun/2018/08/03/排序/","excerpt":"冒泡排序思路分析：在要排序的切片中，对当前还未排好的序列，从前往后对相邻的两个元素依次进行比较和调整，让较大的数往下沉，较小的往上冒。即，每当两相邻的元素比较后发现它们的排序与排序要求相反时，就将它们互换。","text":"冒泡排序思路分析：在要排序的切片中，对当前还未排好的序列，从前往后对相邻的两个元素依次进行比较和调整，让较大的数往下沉，较小的往上冒。即，每当两相邻的元素比较后发现它们的排序与排序要求相反时，就将它们互换。 1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot;)var sli = []int&#123;1, 43, 54, 62, 21, 66, 32, 78, 36, 76, 39&#125;func bubbleSort(sli []int) []int &#123; len := len(sli) //该层循环控制 需要冒泡的轮数 for i := 1; i &lt; len; i++ &#123; //该层循环用来控制每轮 冒出一个数 需要比较的次数 for j := 0; j &lt; len-1; j++ &#123; if sli[i] &lt; sli[j] &#123; sli[i], sli[j] = sli[j], sli[i] &#125; &#125; &#125; return sli&#125;func main() &#123; res := bubbleSort(sli) fmt.Println(res)&#125; 选择排序思路分析：在要排序的切片中，选出最小的一个元素与第一个位置的元素交换。然后在剩下的元素当中再找最小的与第二个位置的元素交换，如此循环到倒数第二个元素和最后一个元素比较为止。 12345678910111213141516171819202122232425262728package mainimport ( &quot;fmt&quot;)var sli = []int&#123;1, 43, 54, 62, 21, 66, 32, 78, 36, 76, 39&#125;func selectSort(sli []int) []int &#123; //双重循环完成，外层控制轮数，内层控制比较次数 len := len(sli) for i := 0; i &lt; len-1; i++ &#123; //先假设最小的值的位置 k := i for j := i + 1; j &lt; len; j++ &#123; //sli[k] 是当前已知的最小值 if sli[k] &gt; sli[j] &#123; //比较，发现更小的,记录下最小值的位置；并且在下次比较时采用已知的最小值进行比较。 k = j &#125; &#125; //已经确定了当前的最小值的位置，保存到 k 中。如果发现最小值的位置与当前假设的位置 i 不同，则位置互换即可。 if k != i &#123; sli[k], sli[i] = sli[i], sli[k] &#125; &#125; return sli&#125; 插入排序思路分析：在要排序的一切片中，假设前面的元素已经是排好顺序的，现在要把第n个元素插到前面的有序切片中，使得这n个元素也是排好顺序的。如此反复循环，直到全部排好顺序。 123456789101112131415161718192021222324252627282930package mainimport ( &quot;fmt&quot;)var sli = []int&#123;1, 43, 54, 62, 21, 66, 32, 78, 36, 76, 39&#125;func insertSort(sli []int) []int &#123; len := len(sli) for i := 0; i &lt; len; i++ &#123; tmp := sli[i] //内层循环控制，比较并插入 for j := i - 1; j &gt;= 0; j-- &#123; if tmp &lt; sli[j] &#123; //发现插入的元素要小，交换位置，将后边的元素与前面的元素互换 sli[j+1], sli[j] = sli[j], tmp &#125; else &#123; //如果碰到不需要移动的元素，则前面的就不需要再次比较了。 break &#125; &#125; &#125; return sli&#125;func main() &#123; res := insertSort(sli) fmt.Println(res)&#125; 快速排序思路分析：选择一个基准元素，通常选择第一个元素或者最后一个元素。通过一趟扫描，将待排序列分成两部分，一部分比基准元素小，一部分大于等于基准元素。此时基准元素在其排好序后的正确位置，然后再用同样的方法递归地排序划分的两部分。 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( &quot;fmt&quot;)var sli = []int&#123;1, 43, 54, 62, 21, 66, 32, 78, 36, 76, 39&#125;func quickSort(sli []int) []int &#123; //先判断是否需要继续进行 len := len(sli) if len &lt;= 1 &#123; return sli &#125; //选择第一个元素作为基准 base_num := sli[0] //遍历除了标尺外的所有元素，按照大小关系放入左右两个切片内 //初始化左右两个切片 left_sli := []int&#123;&#125; //小于基准的 right_sli := []int&#123;&#125; //小于基准的 for i := 1; i &lt; len; i++ &#123; if base_num &gt; sli[i] &#123; //放入左边切片 left_sli = append(left_sli, sli[i]) &#125; else &#123; //放入右边切片 right_sli = append(right_sli, sli[i]) &#125; &#125; //再分别对左边和右边的切片进行相同的排序处理方式递归调用这个函数 left_sli = quickSort(left_sli) right_sli = quickSort(right_sli) //合并 left_sli = append(left_sli, base_num) return append(left_sli, right_sli...)&#125;func main() &#123; res := quickSort(sli) fmt.Println(res)&#125;","categories":[{"name":"算法排序","slug":"算法排序","permalink":"http://blog.yuewei.fun/categories/算法排序/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://blog.yuewei.fun/tags/排序/"},{"name":"算法","slug":"算法","permalink":"http://blog.yuewei.fun/tags/算法/"}]},{"title":"二叉树","slug":"二叉树","date":"2018-08-02T09:22:54.000Z","updated":"2019-08-09T09:30:52.481Z","comments":true,"path":"2018/08/02/二叉树/","link":"","permalink":"http://blog.yuewei.fun/2018/08/02/二叉树/","excerpt":"回顾整理二叉树遍历相关内容。 对于二叉树而言，其遍历有两种方式，一种是深度优先，即先优先向下进行遍历，一种是广度优先，逐层向下遍历。","text":"回顾整理二叉树遍历相关内容。 对于二叉树而言，其遍历有两种方式，一种是深度优先，即先优先向下进行遍历，一种是广度优先，逐层向下遍历。 二叉树结构12345type Tree struct &#123; Val int Left *Tree Right *Tree&#125; 深度优先搜索Deepth-First-Search DFS， 对于深度优先而言，又有三种方式，即前序，中序和后序。前中后序之间的前中后，指的是根结点的位置。 前序递归12345678910func PreOrder(root *Tree) []int &#123; var result []int if root == nil &#123; return result &#125; result = append(result, root.Val) result = append(result, PreOrder(root.Left)...) result = append(result, PreOrder(root.Right)...) return result&#125; 前序非递归123456789101112131415161718192021func PreOrderNonRecursive(root *Tree) []int &#123; var result []int if root == nil &#123; return result &#125; stack := list.New() p := root for p != nil || stack.Len() != 0 &#123; for p != nil &#123; result = append(result, p.Val) stack.PushBack(p) p = p.Left &#125; if stack.Len() != 0 &#123; node := stack.Back() stack.Remove(node) p = node.Value.(*Tree).Right &#125; &#125; return result&#125; 中序递归12345678910func InOrder(root *Tree) []int &#123; var result []int if root == nil &#123; return nil &#125; result = append(result, PreOrder(root.Left)...) result = append(result, root.Val) result = append(result, PreOrder(root.Right)...) return result&#125; 中序非递归123456789101112131415161718192021func InOrderNonRecursive(root *Tree) []int &#123; var result []int if root == nil &#123; return result &#125; stack := list.New() p := root for p != nil || stack.Len() != 0 &#123; for p != nil &#123; stack.PushBack(p) p = p.Left &#125; if stack.Len() != 0 &#123; node := stack.Back() stack.Remove(node) result = append(result, node.Value.(*Tree).Val) p = node.Value.(*Tree).Right &#125; &#125; return result&#125; 后序递归12345678910func PostOrder(root *Tree) []int &#123; var result []int if root == nil &#123; return nil &#125; result = append(result, PreOrder(root.Left)...) result = append(result, PreOrder(root.Right)...) result = append(result, root.Val) return result&#125; 后序非递归1234567891011121314151617181920212223242526func PostOrderNonRecursive(root *Tree) []int &#123; var result []int if root == nil &#123; return result &#125; stack := list.New() p := root lastVisit := new(Tree) for p != nil || stack.Len() != 0 &#123; for p != nil &#123; stack.PushBack(p) p = p.Left &#125; if stack.Len() != 0 &#123; node := stack.Back() if node.Value.(*Tree).Right != nil &amp;&amp; lastVisit != node.Value.(*Tree).Right &#123; p = node.Value.(*Tree).Right continue &#125; result = append(result, node.Value.(*Tree).Val) stack.Remove(node) lastVisit = node.Value.(*Tree) &#125; &#125; return result&#125; 广度优先搜索Breadth-First-Search BFS 或者说是 Level Traversal，对于广度优先而言，其基于队列的数据结构，可以很简单的实现出来 1234567891011121314151617181920func LevelTraversal(root *Tree) []int &#123; var result []int if root == nil &#123; return result &#125; queue := list.New() queue.PushBack(root) for queue.Len() != 0 &#123; node := queue.Front() nTree := node.Value.(*Tree) queue.Remove(node) if nTree == nil &#123; continue &#125; result = append(result, nTree.Val) queue.PushBack(nTree.Left) queue.PushBack(nTree.Right) &#125; return result&#125; 需要注意在for循环里，不能直接用 node.Value.(*Tree) == nil 来判断，因为interface特性，会认为其不为 nil，哪怕nTree为nil。 详细内容，可以参考 go interface机制，这里侧重算法，不再细讲。 总结 二叉树遍历分为两种，一种是深度优先，一种是广度优先 深度优先分为前，中，后序三种实现方式 深度优先可以使用递归和非递归两种方式实现 深度优先主要借助栈来实现 广度优先主要借助队列来实现","categories":[{"name":"算法排序","slug":"算法排序","permalink":"http://blog.yuewei.fun/categories/算法排序/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://blog.yuewei.fun/tags/排序/"},{"name":"算法","slug":"算法","permalink":"http://blog.yuewei.fun/tags/算法/"}]},{"title":"初级算法学习步骤","slug":"初级算法学习步骤","date":"2018-06-13T06:51:05.000Z","updated":"2019-08-07T09:03:00.914Z","comments":true,"path":"2018/06/13/初级算法学习步骤/","link":"","permalink":"http://blog.yuewei.fun/2018/06/13/初级算法学习步骤/","excerpt":"算法可以说是解决问题的步骤。按常理来说学习算法要先掌握一定的数据结构。但因为数组也是一大数据结构，而且也是非常常用的东西，所以在最初，做一些用数组解决的问题（其实java里的数据结构也都是基于数组和类来实现各种数据结构）。","text":"算法可以说是解决问题的步骤。按常理来说学习算法要先掌握一定的数据结构。但因为数组也是一大数据结构，而且也是非常常用的东西，所以在最初，做一些用数组解决的问题（其实java里的数据结构也都是基于数组和类来实现各种数据结构）。 比如一维数组里：计算两个数组的交集，用数组实现约瑟夫环等等；二维数组里（平面坐标初级）：扫雷，边缘检测问题，生命游戏等等。之后进行对数据结构的掌握，会了常用数据结构之后，就可以进行深入的算法研究了。所以这里的建议的顺序是：熟习数组相关操作熟习字符串相关操作认识基础数据结构：线性表、顺序表、链表、栈、队列、树、哈希表、图等。并且自己实现以上数据结构掌握使用提供的数据结构API。排序算法、查找算法。四个基本算法思想：穷举，递推，递归，概率。数学问题，数论问题，数据结构问题，几何问题，字符串问题，大数运算问题。五大常用算法：分治、动态规划（DP），贪心，回溯，分支界定。多看算法题和算法书。 详细内容注：这里都是用java语言作为例子解答代码进行讲解，同时附带的也都是java的api使用说明，但其实算法对语言依赖性不大，重要的是思想。本文提供给大家一个学习方案作为参考。 数组内容：熟习数组的常用操作，可以做一些基础题，可以上leetcode或者别的算法题网站，刷掉初级算法题库里的数组10几个题目，这样对一维和二维数组的掌握灵活度就比较高了。一个比较典型的二维数组逻辑题目：旋转二维数组：给定一个n×n的二维矩阵表示一个图像，输出将图像旋转90度的样子。（不要用另一个矩阵来旋转）题目具体内容点击标题可以进去查看。其他数组例题：两个数组的交集，数组实现约瑟夫环，简易扫雷，生命游戏等等。其他数组的操作大家可以自行去看看别的题，锻炼一下数组的运用思想。 字符串内容：字符串的操作，比如回文串判定、字符串翻转等等。同样建议上题库做一些相应练习。在java里对应的API：string，stringbuilder，stringbuffer。 数据结构此章内容具体参照：java数据结构和他的API内容：这一部分需要自己先去学习一遍数据结构，然后自己写出来。掌握之后，再去查看api文档，最后学会如何使用api里的数据结构写算法，下面介绍的主要是api的对应方式。1、基础数组、线性表：（1）数组：API：Arrays。（2）线性表：API：ArrayList。2、链表：链表是以节点类为基础的，每个节点类有一个成员变量是下一个节点。API：LinkedList。3、集合（java）：API：Collections。这个接口提供了很多常用方法，具体如何使用可以参照帮助文档。4、向量：（可增长数组）API：Vector接口提供方法与数组类似，具体查看API帮助手册。5、栈：自己先基于数组去实现。API：Stack接口提供查看，移除，压入，查找，判空操作6、队列、双端队列、优先队列：（1）队列：API：Queue。（2）双端队列：API：Deque。（3）优先队列： API：PriorityQueue档。7、哈希表（映射表）：API：（1）Hashmap提供了键—值对应的功能。（2）TreeMap提供了可排序的映射表。8、树：树没有api，可以用上面学过的东西去实现它。9、图：图也是没有api的，用之前学过的结构可以构造。 排序内容：在排序里，需要了解这九大排序算法：1、冒泡排序：每两个交换，每轮吧最大的放后面；2、选择排序：每轮选出最大的放后面；3、插入排序：一个线性表，一开始只有一个元素，加一个排一个；4、希尔排序：5、快速排序：6、堆排序：7、合并排序：8、基数排序：9、计数排序： 查找这个阶段要了解到查找算法在平时的应用，最基础的是直接查找和二分查找，但是有时候在不同场景会有一些优化。1、二分法：对排序好的数组用，Collections提供了此方法2、二分法的各种优化搜索：3、数据结构中的查找：（1）顺序表：同数组，序号或者关键字顺序、二分查找。（2）链表：关键字查找，只能一个个往后找，返回引用。（3）树：树或者二叉树遍历一个个找，二叉搜索树可以根据大小找，原理和二分法一样。平衡二叉树同而搜索树，红黑树效率高。（4）图：深度优先遍历查找。 4个基本算法思想此章节具体参照：4个基本算法思想：穷举、递推、递归、概率内容：这4个基本算法思想是解决基础问题的很实用的方法。这里开始其实就已经是把所有需要的知识准备好了，之后就要开始解题了。1、穷举：暴力破解，n层for循环。枚举每一种可能。2、递推：简单的动态规划，根据递推公式，累加。3、普通递归：化解问题逐渐变小（从n到1）4、概率：使用random数量足够大的时候，得到近似结果。 数学问题，数论问题，数据结构问题，几何问题，字符串问题，大数运算问题：内容：这一块需要了解的是零散问题的应用。每一块我举几个例子，推荐大家还是上刷题网站吧零散的题给刷掉，不推荐直接做各个算法难题，先做这些零散题会对之后系统做算法有一些帮助。以下我诺列一些题目，大家可以自己查查，刷题网站上也有。1、数学问题：罗马数字转换Math函数的应用（自行查看api帮助文档）。保留小数点的操作：例如String.format（“%.2f”,string）2、数据结构问题：约瑟夫环：具体点击这里括号匹配：具体点击这里链表排序、最短路径等等。3、数论问题：素数、完全数为代表的问题。4、几何问题：java里有API：抽象类shape——具体类line2d，Point2d提供了一些集合方法。5、大数运算问题：API：BigInteger，提供加减乘除模，大小比较，转化等运算。6、字符串问题：API：String大致包含这些方法：是否包含，比较（可不考虑大小写），第一次出现索引（前后），两个字符串的某个区域是否相等（regionmatches），replace替换，split（[，]）分割，substring删减，tochararray变成字符数组，tolow/toup，trim忽略前后空白，valueof把别的转换成字符串。 五大常用算法五大算法：分治，回溯，贪心，DP（动态规划），分支界定。内容在这一块是需要重点看看的，前4个是重点，也有非常多的经典例题。这一部分还是比较需要时间的，以下仅仅是介绍，点开链接具有详细的每个算法讲解。 1、分治法首先看一下二分搜索：一串数，取中间的数并且平分两半，如果比中间数大，就去上半部分找，然后再两半……这样查找就是分治思想：把一个问题分解成若干个一样的小块。具体详情：分治算法——五大常用算法之一基本概念：把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题。直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。 2、动态规划法具体详情：动态规划——五大常用算法之一基本概念：动态规划（DP）就是：每走一步，都会根据之前的情况来决定这一步的走向，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。使用动态规划法一般会有一个递推公式（递推就是简单动态规划）。当然，最难找到的也是这个递推公式。 3、贪心算法具体详情：贪心算法——五大常用算法之一基本概念：在对问题求解时，总是做出在当前看来是最好的选择。不从整体最优上加以考虑，所做出的仅是在某种意义上的局部最优解。贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。 4、回溯算法具体详情：回溯算法——五大常用算法之一基本概念： 回溯算法实际上一个类似枚举的搜索尝试过程（排列组合），主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。 许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。 5、分支界定这个算法个人没有仔细研究，可能是因为学的较浅没有经常用到。下面内容做一个参考：基本描述 类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。","categories":[{"name":"算法排序","slug":"算法排序","permalink":"http://blog.yuewei.fun/categories/算法排序/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://blog.yuewei.fun/tags/算法/"}]},{"title":"操作系统引论","slug":"操作系统引论","date":"2017-08-06T02:38:56.000Z","updated":"2019-08-07T09:01:55.105Z","comments":true,"path":"2017/08/06/操作系统引论/","link":"","permalink":"http://blog.yuewei.fun/2017/08/06/操作系统引论/","excerpt":"操作系统（OS）是计算机上第一层软件，对硬件系统的首次扩充。主要作用管理好这些设备，提高利用率和吞吐量，并为用户和应用进程提供一个简单的接口，便于使用。","text":"操作系统（OS）是计算机上第一层软件，对硬件系统的首次扩充。主要作用管理好这些设备，提高利用率和吞吐量，并为用户和应用进程提供一个简单的接口，便于使用。 操作系统的作用和目标操作系统目标 方便性 未配置OS的需要机器语言 有效性 提高系统资源利用率 提高系统吞吐量：合理组织计算机的工作流程，加速程序运行，缩短运行周期 可扩充性 可扩充性好坏与OS结构十分紧密联系 OS结构发展：无结构···模块化结构···层次结构···微内核结构（可以方便添加新的功能模块） 开放性 遵循世界标准规范，特别是遵循开放系统互连OSI国际标准 操作系统作用 OS作为用户与计算机硬件系统之间的接口 OS处于用户与计算机系统之间，用户通过OS来使用计算机系统 通过命令、系统调用、图标-窗口方式来完成通信 OS作为计算机系统资源的管理者 这些资源分为四大类：处理机、存储器、I/O设备、文件（数据和程序） 处理机 ： 用户分配和控制处理机 存储器 ： 主要负责内存分配和回收 I/O设备： 负责I/O设备的分配（回收）操作 文件管理： 用于实现对文件的存取、共享和保护 OS 实现了对计算机资源的抽象 完全无软件的计算机系统（裸机） 裸机上铺设I/O设备称为扩充器或虚拟机 I/O 设备实现对计算机硬件操作的第一层抽象 文件管理实现对计算机硬件操作的第二层抽象（功能更强的虚拟机） 推动操作系统发展的主要动力 不断提高计算机的利用率 方便用户 硬件的不断更新 计算机体系结构的不断发展 不断提出新的应用需求 操作系统的发展过程未配置操作系统的计算机系统 人工操作方式 人工操作穿孔的纸带（卡片） 缺点: 用户独占全机 CPU等待人工操作 人工操作方式严重降低了计算机利用率 脱机输入/输出方式 将原有纸带装入纸带输入机，在一台外围机的控制下把纸袋上的数据（程序）放到磁盘上 有点： 减少CPU空闲时间 提高I/O的速度 单道批处理系统 单道批处理系统的处理流程 监督程序将磁带上的作业一个一个顺序执行 单道批处理系统缺点 系统中资源得不到重复利用 多道批处理系统 多道批处理系统处理流程 用户提交作业在外存上，排成一个队列（后备队列），作业调度根据一定算法，一次取多个调入内存，减少CPU的空当时间 多道批处理系统的缺点 资源利用率高 系统吞吐量达 CPU和其他资源保持“忙碌”状态 仅当作业完成、或运行不下去时在进行切换，系统开销小 平均周转时间长 无交互能力 多道批处理系统需要解决的问题 问题： 处理机挣用问题 内存分配和保护问题 I/O 设备分配问题 文件的组织和管理问题 作业管理问题 用户与系统的接口问题 分时系统 分时系统的引入 人——机交互 共享主机 分时系统是指，在一台计算机上连接多个鼠标、显示器的终端所组成的系统，该系统运行多个用户同时访问，共享主机资源 分时系统的关键问题 及时接受 及时处理 分时系统的特新 多路性 独立性 及时性 交互性 实时系统 时间作为关键参数，收到某些信号“及时”、“实时”的反响 实时系统的类型 工业控制系统 信息查询系统 多媒体系统 嵌入式系统 实时任务类型 周期性和非周期性实时任务 硬实时任务和软实时任务 （必须小于截至截止时间，不一定小于截止时间） 实时系统与分时系统比较 多路性 独立性 及时性 交互性 可靠性 微机操系统作发展史 单用户单任务操作系统 单用户多任务操作系统 多用户多任务操作系统 并发并发和并行 并行 两个或多个事件在同一时刻运行 并发 两个或多个事件在同一时间间隔内发生 引入进程在属于同一个计算程序和I/O程序之间只能顺序执行，即只有在计算程序执行告一段落后，才允许I/O程序执行，反之在执行I/O操作时计算程序也不能执行。但在为计算程序和I/O程序分别建立一个进程后两个进程可以并发执行 进程 在系统中能够独立运行并作为资源分配的基本单位，它是由一组机器指令、数据、堆栈等组成的，是以独立的活动实体。多个进程之间可以并发执行和交换信息。 共享 共享与操作环境下的共享（含义不一致） 共享 某种资源能被大家使用 操作系统环境下的共享（资源复用） 指操作系统中的资源可供内存中多个并发执行的进程共同使用 互斥共享方式系统中的某些资源虽然可以提供给多个进程（线程）使用，但在规定的时间内只有一个进程访问资源，为此建立了互斥访问 同时访问方式系统中有一类资源允许同一时间由多个进程“同时”访问 并发和共享是多用户（多任务）OS的两个最基础的特征。 虚拟时分复用技术广泛利用时分复用技术来实现虚拟处理机、虚拟设备等，是资源利用率提高。原因：利用某设备为一个用户服务空闲时间又转去为其他用户服务，使得设备得到充分利用。 虚拟处理技术 虚拟设备技术 空分复用技术将一个频率范围比较宽的信道划分为多个窄的信道（称为频带），其中的任何一个频带仅供一对用户通话。 操作系统的主要功能处理机管理功能 进程控制 进程控制的主要功能也就是作为穿件进程、撤销（终止）已接收的进程，控制进程在运行时状态的转换 进程同步 进程互斥方式 访问临界资源时采用互斥：为每一个临界资源配置一把锁（W），当锁打开时才可以访问，关闭时禁止访问 进程同步 多个进程去做一件事情，有同步机构对他们执行次序加以协调：信号量机制 进程通信 由源进程利用发送消息命令直接将消息挂载到目标进程得到消息队列上，由目标进程利用接收命令消息队列中取出消息 调度 作业调度 任务是从后备队列中按照一定的算法选择处若干个作业，为他们分配运行所需资源，再讲这些作业调入内存后， 分别为他们建立进程，使它们成为可能获得处理机的就绪，并将它们插入到就绪队列中 进程调度 从进程的就绪队列中按照一定的算法选出一个进程，将处理机分配给他，并为他设置运行现场，使其投入执行 存储器管理功能功能：为多道程序的运行提供良好的环境，提高存储器利用率，方便用户使用，从逻辑上扩充内存。 内存分配回收 为每道程序分配内存空间，使他们“各得其所” 提高存储器利用率，减少不可用的内存空间 允许正在运行的程序申请附加内存空间，适应程序动态增长 OS 内存分配动态和静态两种方式： 静态 每个作业的内存空间在装入时确定，运行期间不能申请新的空间，不能在内存中移动 动态 每个作业的内存空间在装入时确定，运行期间可以继续申请新的空间，以适应程序数据的动态增长，运行在作业内存中移动 内存保护 确保每道用户程序都仅能在自己的空间内运行，彼此互不干扰 觉不允许用户程序访问操作系统的程序和数据，也不允许用户程序转移到非共享的其他用户程序中执行 内存保护机制设置两个界限寄存器 对每条指令所要访问的地址进行检查，如发生越界，发出越界中断请求，停止程序的执行 地址映射 逻辑空间中的逻辑地址转换为空间中与之对应的物理地址 内存扩充 借助于虚拟存储技术，从逻辑上扩充内存容量，让用户感觉到内存容量比实际大的多，让用户程序能并发运行 请求调入功能 置换功能：将不需要挂起至硬盘，需要的转入内存 设备管理功能主要任务： 完成用户进程提出的I/O请求，为用户分配所需的I/O设备，并完成指定的I/O操作 提高CPU和I/O的利用率，提高I/O速度，方便用户使用I/O设备 缓存管理 I/O设备和CPU设备之间引入缓存，有效的缓和CPU和I/O设备速度不匹配的矛盾，提高CPU的利用率，进而提高系统吞吐量 常见缓存机制 都由 OS缓存机制管理： 单缓存机制 能够实现双向同时传送数据的双缓存机制 能够供多个设备同时使用的公共缓存池机制 设备分配 根据用户进程的I/O请求、系统现有资源情况及按照某种设备分配策略，为之分配所需设备 设备处理 实现CPU和设备控制器之间的通信 文件管理功能功能： 对用户文件和系统文件进行方便用户使用，并保证文件安全性。 文件存储空间管理 为每个文件分配必要的空间，提高外存利用率，进而提高文件系统的存、取速度。为此操作系统设置相应数据结构，堆内存空间进行分配和回收 目录管理 文件读写管理和保护 文件读写管理 文件保护 操作系统与用户的接口 用户接口 联机用户接口 脱机用户接口 图形用户接口 程序接口 现代操作系统新功能 系统安全 认证技术 密码技术 访问控制技术 反病毒技术 网络的功能和服务 网络通信 资源管理 应用互操作 支持多媒体 接纳控制功能 实时调度 多媒体文件的存储 OS的设计","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://blog.yuewei.fun/categories/操作系统/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://blog.yuewei.fun/tags/操作系统/"}]},{"title":"Linux","slug":"Linux","date":"2017-08-04T05:09:52.000Z","updated":"2019-09-06T09:34:45.192Z","comments":true,"path":"2017/08/04/Linux/","link":"","permalink":"http://blog.yuewei.fun/2017/08/04/Linux/","excerpt":"LINUX常用命令（基础） man 对你熟悉或不熟悉的命令提供帮助解释 eg:man ls 就可以查看ls相关的用法","text":"LINUX常用命令（基础） man 对你熟悉或不熟悉的命令提供帮助解释 eg:man ls 就可以查看ls相关的用法 注：按q键或者ctrl+c退出，在linux下可以使用ctrl+c终止当前程序运行。 ls 查看目录或者文件的属*，列举出任一目录下面的文件 eg: ls /usr/man ls -l d表示目录(directory)，如果是一个”-“表示是文件，如果是l则表示是一个连接文件(link) 表示文件或者目录许可权限.分别用可读(r)，可写(w)，可运行(x)。 cp 拷贝文件 eg: cp filename1 filename2 //把filename1拷贝成filename2 cp 1.c netseek/2.c //将1.c拷到netseek目录下命名为2.c rm 删除文件和目录 eg: rm 1.c //将1.c这个文件删除 mv 移走目录或者改文件名 eg: mv filename1 filename2 //将filename1 改名为filename2 mv qib.tgz ../qib.tgz //移到上一级目录 cd 改变当前目录 pwd 查看当前所在目录完整路径 eg: pwd //查看当前所在目录路径 cd netseek //进入netseek这个目录 cd //退出当前目录 cat，more命令 将某个文件的内容显示出来。两个命令所不同的是:cat把文件内容一直打印出来，而 more则分屏显示 eg; cat&gt;1.c //就可以把代码粘帖到1.c文件里，按ctrl+d 保存代码。 cat 1.c 或more 1.c //都可以查看里面的内容。 gcc -o 1 1.c //将1.c编译成.exe文件，我们可以用此命编译出代码。 chmod 命令 权限修改 用法：chmod 一位8进制数 filename。 eg: chmod u+x filenmame //只想给自己运行，别人只能读 //u表示文件主人， g 表示文件文件所在组。 o 表示其他人 ;r 表可读，w 表可写，x 表可以运行 chmod g+x filename //同组的人来执行 clear，date命令 clear:清屏，相当与DOS下的cls;date:显示当前时间。 mount 加载一个硬件设备 用法:mount [参数] 要加载的设备 载入点 eg: mount /dev/cdrom cd /mnt/cdrom //进入光盘目录 su 在不退出登陆的情况下，切换到另外一个人的身份 用法: su -l 用户名(如果用户名缺省，则切换到root状态) eg:su -l netseek (切换到netseek这个用户，将提示输入密码) whoami，whereis，which，id //whoami:确认自己身份 //whereis:查询命令所在目录以及帮助文档所在目录 //which:查询该命令所在目录(类似whereis) //id:打印出自己的UID以及GID。(UID:用户身份唯一标识。GID:用户组身份唯一标识。每一个用户只能有一个唯一的UID和 GID) eg: whoami //显示你自已登陆的用户名 whereis bin 显示bin所在的目录，将显示为：/usr/local/bin which bin grep，find grep:文本内容搜索;find:文件或者目录名以及权限属主等匹配搜索 eg: grep success * /*查找当前目录下面所有文件里面含有success字符的文件 kill 可以杀死某 个正在进行或者已经是dest状态的进程 eg; ps ax passwd 可以设置口令 history 用户用过的命令 eg: history //可以显示用户过去使用的命令 !! 执行最近一次的命令 mkdir命令 eg: mkdir netseek //创建netseek这个目录 tar 解压命令 eg: tar -zxvf nmap-3.45.tgz //将这个解压到nmap-3.45这个目录里 finger 可以让使用者查询一些其他使用者的资料 eg: finger //查看所用用户的使用资料 finger root //查看root的资料 本文讲解了Linux创建文件命令的方法 ,希望对您的学习有所帮助。 创建文件夹 mkdir aaa mkdir -p aaa 创建文件命令 vi foo.txt emacs foo.txt echo “aaaa” &gt; foo.txt cat &gt; foo.txt 清除命令 foo.txt mkdir /home/u1 创建文件夹/home/u1 chown oracle /home/u1 表示改变目录所有者为oracle账户; chgrp dba /home/u1 改变/home/u1目录为dba所有; chmod 755 /home/u1 表示oracle账户对/home/u1目录有755权限; rmdir /home/u1 表示删除/home/u1目录 hostname可以查看linux的计算机名; whoami可以查看当前用户; pwd显示当前路径; df查看系统的硬件信息 ls -lrt l表示显示详细列表，-t表示按时间排序,-r反向排序 cat orcl_ora_3436.trc|grep bucket 以下查看相关文件内容: more /etc/oratab cat /etc/passwd cat /etc/group 以上是Linux创建文件命令的方法。 linux中创建文件用touch 例如：touch 1.txt 删除文件用rm 例如：rm -f 1.txt 创建目录用mkdir 例如：mkdir daiyuanqi 删除空目录用rmdir 例如：rmdir daiyuanqi （有东西的目录不能删） 删除装有东西的目录就用rm -rf 例如rm -rf XXX","categories":[{"name":"算法排序","slug":"算法排序","permalink":"http://blog.yuewei.fun/categories/算法排序/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://blog.yuewei.fun/tags/服务器/"}]},{"title":"CentOS7安装过程","slug":"CentOS7安装过程","date":"2017-08-04T05:01:32.000Z","updated":"2019-08-07T09:02:20.690Z","comments":true,"path":"2017/08/04/CentOS7安装过程/","link":"","permalink":"http://blog.yuewei.fun/2017/08/04/CentOS7安装过程/","excerpt":"安装UltraISO官网搜索next 从U盘安装CentOS7.3教程 准备工作: 一台没系统的普通电脑 u盘一个（大于1G，最小安装的话不超过1G，根据选择系统大小匹配U盘即可） CentOS7.3 iso文件一个 UltraISO工具","text":"安装UltraISO官网搜索next 从U盘安装CentOS7.3教程 准备工作: 一台没系统的普通电脑 u盘一个（大于1G，最小安装的话不超过1G，根据选择系统大小匹配U盘即可） CentOS7.3 iso文件一个 UltraISO工具 制作U盘 使用UltraISO工具 文件-》打开 选择你的ISO文件 先使用UltraISO刻录镜像至U盘内（PS:刻录的时候隐藏启动分区可以选成无，里面的packages文件夹可以删除，这个文件夹是没什么用的，而且大小挺大的，因为安装的时候有镜像在U盘内） 开始安装 把制作好的U盘插入需要安装Linux的电脑，把电脑的第一启动方式设置为U盘启动之后 会进入选择安装界面 接下来就是最重要的地方，关系着你能不能安装成功 我就是在这里卡了好久 先移动到第二项test &amp;Install 然后按e键编辑路径 将vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\\x207\\x20x86_64 quiet改成vmlinuz initrd=initrd.img linux dd quiet ctrl+x 然后就能在显示出的列表中 查看你的硬盘信息，很清晰就能知道哪一个是你的U盘（一般显示的几个 格式为NTFS的都是你电脑自身的盘符，另外的一个就是你的U盘，记下你的U盘的盘符名字 我的就是sda4）使用ctrl+alt+del 重新启动电脑，重复上面的步骤 这一次 将vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\\x207\\x20x86_64 quiet改成vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sda4（你自己的U盘盘符） quiet ctrl+x 等待安装程序启动，进行CentOS的安装 Linux引导安装 选择中文安装 选择时区，设置时间，能够在网络与主机里面连接wifi之后 在时间设置里面使用网络时间 选择软件的安装源 U盘安装一般是默认选择 一般是Packages文件夹，不用管 比较常用的是最小化安装（安装快，只有命令行操作） 带有桌面的安装（一些配置和使用都可以图形化操作，较好用） 服务器版安装（特定组件可以省掉自己安装的很多问题），这里选择最小化安装，另外可以根据自己的需要从右面选择部分组件安装 刚开始接触Linux的朋友建议使用GHOME图形操作界面，好上手 网络和主机名里面配置网络信息 我这里是用的虚拟机安装 所以安装位置只能选择虚拟机，但是在真机安装的时候 需要选择具体的安装位置，如果之前电脑用过WIndows 硬盘已经分区了 需要进行磁盘释放，之后选择安装位置 全部信息确认完毕之后 就可以开始安装了 在这里可以新建用户 设置root操作 等待下方安装进度完成 之后就能进入Linux系统了 解决CentOS7 用U盘 无法进入安装界面 这是用uefi方式启动的CentOS的版本是1708 首先按”e”键进入编辑界面将inst.stage2=hd:LABEL=CentOS\\x207\\x20x86_64 改为linux dd 按”ctrl + x”执行 然后找到那个驱动器 这里是sdd4 重新进入引导界面，修改以下信息 从inst.stage2=hd:开始，修改为/dev/sdd4 (这是自己的U盘位置) 按”ctrl + x” 稍等片刻，就可以安装CentOS7了","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://blog.yuewei.fun/tags/服务器/"}]},{"title":"进程的描述与控制","slug":"进程的描述与控制","date":"2017-07-06T10:09:25.000Z","updated":"2019-08-29T02:26:08.939Z","comments":true,"path":"2017/07/06/进程的描述与控制/","link":"","permalink":"http://blog.yuewei.fun/2017/07/06/进程的描述与控制/","excerpt":"前趋图和程序执行前趋图指一个有向无循环图，用于描述进程之间执行的先后顺序","text":"前趋图和程序执行前趋图指一个有向无循环图，用于描述进程之间执行的先后顺序 程序顺序执行程序的顺序执行一个程序由若干程序组组成，每一个程序段完成特定的功能，在执行时按照先后顺序依次执行，仅前一段程序执行后，才会执行下一段程序 程序执行的特征 顺序性 严格按照规定顺序执行 封闭性 独占全集资源，只有程序本身可以改变资源状态，不受未接影响 可再现性 程序初始环境和执行环境相同，不论怎么执行都可获得相同结果 程序并发执行程序并发执行不存在前趋关系，可以并发执行 程序并发执行时的特征并发执行时，提高了系统的吞吐量、资源利用率，由于他们共享系统资源，是他们在执行程序时必形成相互制约关系 间断性 共享系统资源，完成统一任务相互合作，使得这些程序之间形成制约关系，导致程序“执行————暂停————执行”间断性活动规律 失去封闭性 资源共享，其中任一程序改变都会受到其他程序影响 不可再现性 失去封闭性，导致不可再现性 进程的描述进程的定义和特征进程的定义为了使并发执行的程序（含数据）都能独立运行，在操作系统中必须为配置一个专门的数据结构称之为进程控制块，一般情况下我们把进程实体就简称为进程，创建进程实质是创建进程实体中的PCB；撤销进程实质是撤销进程的PCB 进程是程序的一次执行 进程是一个程序及其数据在处理机上顺序执行时所发生的活动 进程是具有独立功能的程序在一个数据集合上运行的过程，他是系统进行资源分配和调度的一个独立单位 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位 进程的特征 动态性：进程的实质是进程实体的执行过程，“他由创建而产生，有调度而执行，有撤销而消亡”，可见进程有一定的生命周期。而程序只是一组有序指令集合，是静态的。 并发性：进程实体同存于内存中，且能在一段时间内运行。程序（没有建立PCB）是不能参与并发执行的 独立性：进程实体是一个能独立运行、独立获得资源和独立接收调度的基本单位 异步性：进程是按异步方式运行的，即按各自独立的、不可预知的速度向前推进 进程的基本状态及转换进程的三种基本状态 就绪状态 进程已获取除CUP外所有必要资源，只要获得CPU，便可立即执行 系统中有许多出于就绪状态的进程，通常将他们按照一定的策略排成一个队列，成就绪队列 执行状态 已获得CPU，正在执行的状态 单机处理系统中，只有一个进程处于执行状态 多处理机系统中，多个进程处于执行状态 阻塞状态 正在执行进程由于发生某些事件暂时无法继续执行的状态 此时OS把处理机分配给另外一个就绪进程，而让受阻进程处于暂停状态称为苏泽状态 在较大系统中根据阻塞原因不能，设置多个阻塞队列 三种状态基本转换 创建状态和终止状态 创建状态 申请一个空白PCB，向PCB中填写用于管理和控制的进程信息 为该进程分配运行时所必须的资源 把该进程转入就绪态并插入就绪队列中 如果进程所需资源商不能满足，进程不能被调度运行，此时进程属于创建状态 为保证进程调度必须在创建完成后进行，与确保进程控制块的完整性 终止状态 等待操作系统善后处理 将其PCB清零，将PCB返还系统 挂起操作和进程状态的转变当挂起操作用于某个进程时，该进程将被挂起，意味着此时该进程处于静止状态。如果进程正在执行，它将暂停执行。若原本处于就绪状态，则该进程此时暂时不接受调度。与挂起操作对于的是激活操作 挂起操作的引入 终端用户的需要 运行时发现问题，暂停程序运行 父进程请求 父进程挂起自己某个进程 负荷调节的需要 操作系统的需要 引入挂起原语操作后三个进程状态转换 活动就绪—&gt;静止就绪 活动阻塞—&gt;禁止阻塞 禁止就绪—&gt;活动就绪 禁止阻塞—&gt;活动阻塞 引入挂起操作后五个进程状态的转换 NULL -&gt; 创建 创建 -&gt; 活动就绪 创建 -&gt; 静止就绪 执行 -&gt; 终止 进程管理中的数据结构操作系统中用于管理控制的数据结构在计算机系统中，对于每个资源和每个进程都设置了一个数据结构，用于表征其实体，我们称之为资源信息表或进程信息表，其中包含了资源或进程的标识、描述、状态等信息以及一批指针。通过这些指针，可以将同类资源或进程的信息表，或者同一进程所占用的资源信息表分类链接成不同的队列，便于操作系统进行查找。 OS管理的这些数据结构一般分为以下四类：内存表、设备表、文件表和用于进程管理的进程表，通常进程表又被称为进程控制块PCB。 进程控制块PCB的作用 作为独立运行基本单位的标志 进程配置PCB后就表示他已是一个能在多道环境下独立运行的合法的基本单位，PCB称为进程存在系统的唯一标识 能实现间断性运行方式 采用停停走走的间断性的运行方式运行 提供进程管理所需信息 提供进程调度所需信息 实现与其他进程的同步与通信 进程控制块中的信息 进程标识符：唯一标识一个进程。一个进程有两个标识符 外部标识符 方便进程间调用 内部标识符 方便系统对进程调用 处理机状态 通用寄存器 指令计时器 程序状态字PSW 用户占指针 进程调度信息 进程状态，指明进程的当前状态，它是作为进程调度和对换时的依据； 进程优先级，是用于描述进程使用处理机的优先级别的一个整数，优先级高的进程应优先获得处理机； 进程调度所需的其他信息，它们与所采用的进程调度算法有关，比如，进程已等待CPU的时间总和、进程已执行的时间总和等； 事件，是指进程由执行状态转变为阻塞状态所等待发生的事件，即阻塞原因。 进程控制信息 进程和数据的地址，进程实体中的程序和数据的内存或外存地(首)址，以便再调度到该进程执行时，能从PCB中找到其程序和数据； 进程同步和通信机制，这是实现进程同步和进程通信时必需的机制，如消息队列指针、信号量等，它们可能全部或部分地放在PCB中； 资源清单，在该清单中列出了进程在运行期间所需的全部资源(除CPU以外)，另外还有一张已分配到该进程的资源的清单 连接指针，它给出了本进程(PCB)所在队列中的下一个进程的PCB的首地址。 进程控制块的组织方式 线性方式 放入线性表中，将该表的首址存放在内存的一个专用区域中 链接方式 链接成一个对列 索引方式 根据状态不同建立几张索引表 进程控制进程控制是进程管理的最基本部分，主要包括创建进程、终止已完成进程、将因发生异常情况而无法继续运行的进程处于阻塞状态、负责进程运行中的状态转换等功能。 进程系统内核 系统泰（管态/内核态） 有较高特权，能执行一切指令，访问所有寄存器和存储区，传统系统都在系统态中运行 用户态（目态） 有较低的特权，仅能执行规定的指令，访问指定的寄存器和存储区 支撑功能 中断处理 内核最基本的功能 始终管理 内核一项基本功能 原语操作 有若干指令组成的 进程的创建允许一个进程创建另一个进程，创建进程称为父进程，被创建进程子进程，在UNIX中形成进程家族（组），子进程继承父进程拥有资源 申请空白PBC，为新进程申请获得唯一的数字标识 为进程分配所需资源 初始化进程控制块 初始化标识信息，将系统分配的标识符和父进程标识符填入新PCB中 初始化处理机状态信息，使程序计数器指向程序的入口地址 初始化处理机控制信息，设置进程状态（就绪、静止状态） 放入就绪队列（有空间） 进程的终止 引起进程终止事件 正常结束 进程的任务已经完成，准备退出运行 异常结束 越界错 程序锁访问的存储区，已越出该进程的区域 保护错 访问不允许方的资源或文件 不适当的方式访问 例：写一个只读文件 非法指令 执行不存在指令 特权指令错 用户进程执行OS的指令 运行超时 进程执行时间超出指定时间最大值 等待超时 进程等待时间超出指定时间的最大值 算数运算错 执行一个禁止的运算 I/O 故障 在I/O过程中发生了错误 外界干预 操作员或操作系统干预 父进程请求 因父进程终止 进程的终止及过程 根据被终止进程标识符，从PCB集合中检索出该进程PCB，从中读取该进程状态 若被终止进程处于执行状态，应立即终止进程的执行，设置调度标志为真，用于指示该进程被终止后应重新进行调度 有子孙进程先结，将所有子孙进程终止，防止他们成为不可控进程 把拥有的全部资源还给父进程，或者归还系统 被终止进程（PBC）从所在队列（或链表）移出 进程的阻塞和唤醒引起进程阻塞和唤醒的事件 向系统请求共享资源失败 进程向系统请求共享资源时，系统无足够资源，此进程不能继续运行 等待某种操作的完成 新数据尚未到达 等待新任务的到达 进程阻塞过程（block）阻塞市金城自身得的一种主动行为，执行–&gt;阻塞，将PCB插入阻塞队列 进程唤醒过程（wakeup）被阻塞进程所起的事件发生后，有关进程调用wakeup将改时间的进程唤醒。wakeup执行过程： 把被阻塞进从等待该事件的阻塞队列中移除 将其PCB中的现行状态油阻塞改为就绪 将该PCB插入到就绪队列中 进程的挂起与激活进程的挂起发生挂起进程事件后，OS将调用挂起原语suspend将制定进程或处于阻塞状态的进程挂起suspend 执行过程 检查被挂起进程的状态（处于活动、就绪状态改为禁止就绪状态） 活动阻塞状态进程，改为禁止阻塞 把该进程的PCB复制到制定的内存区域 若被挂起的进程正在运行，则转向调度程序重新调度 进程的激活过程发生激活事件后，OS利用激活active将指定进程激活 进程同步硬件同步机制、信号量机制、管程机制 进程同步的基本概念多个相关进程在执行次序上进行协调，使并发执行的诸进程之间按照一定规则共享系统资源 两种形式制约关系 间接相互制约关系 共享系统资源，使这些并发执行的程序之间形成相互制约的关系 直接相互制约关系 完成某项任务建立多个进程。这些进程完成同一项额任务而相互合作 临界资源 打印机 磁带机 临界区 每个进程中访问临界资源的代码称之为临界区 进入临界区之前，先对临界资源进行检查，看他是否正在被访问。若正在被访问，进程便可进入临界区对该资源进行访问，并设置正在访问标识1234567while(true)&#123; 进入区 临界区 退出区 剩余区&#125; 同步机制应遵循的规则 空闲让进 忙则等待 有限等待 让权等待 硬件同步机制关中断进入锁测试之前关闭中断，知道完成锁测试并上锁之后才能打开中断 利用Test-and-Set指令实现互斥利用Swap指令实现进程互斥信号量机制整形信号量整型信号量定义为一个用于表示资源数目的整形量S，他与一般整型量不同，除初始化仅能通过两个标准的原子操作wait(S)和signal(S)来访问，被称为P、操作。原子操作不可中断 12345678wait(S)&#123; while(S&lt;=0); S--&#125;signal(S)&#123; S++&#125; 记录信号量一、整形信号量wait操作，只要S&lt;= 就会不断地测试（未遵循“让权等待”的准则）而是进程处于忙等状态二、记录型信号量机制不存在“忙等”现象的进程机制。但采取了“让权等待”后，会出现多个进程同时访问同一临界区资源，需要一个用于代表资源数目的变量value外还需要一个进程链表指针list，用于连接所有上述等待进程 AND型信号量基本思想：进程在整个运行过程中需要的所有资源，一次性全部地分配给进程，待进程使用完后再一起释放。 信号量的应用利用信号量实现进程互斥为使多个进程能互斥的访问某临界资源，只需为该资源设置一互斥信号量mutex，并设其初始值为1 当mutex=0时，表示有一个进程进入临界区运行，另外一个必须等待，挂入阻塞队列； 当mutex=-1时，表示有一个进程正在临界区运行，另外一个进程因等待二阻塞在信号量队列中，需要被当前已在临界区运行的进程退出时唤醒 利用信号量实现前去关系管程机制管程定义系统中各种硬件资源和软件资源均可用数据结构抽象的描述其资源特性，即少量信息和对该资源锁执行的操作来表示资源，而忽略他们的内部结构和实现细节。 管程的名称 局部于管程的共享数据结构说明 对该数据结构进行操作的一组过程 对局部于管程的共享数据设置初始值得语句 线程的基本概念线程的引入OS中引入进程目的为了使程序并发执行，提高资源利用率和系统吞吐量OS中一如线程则是为了减少程序在并发执行时所付出的时空开销，使OS有更好的并发性 进程的两个基本属性 进程是一个可拥有独立资源的独立单位，一个进程要独立运行，必须拥有一定资源（存放程序正文、数据的磁盘和内存地址空间以及I/O设备打开的文件、信号量等） 进程同时又可是一个可独立运行调度和分配的基本单位，一个进程要独立运行，必须是一个可独立调度和分配的基本单位。每个进程在系统中有唯一的PCB，系统可根据其PCB感知进程的存在，也可以根据PCB中的信息对进程进行调度，还可以将端点信息保存在PCB中，利用进程PCB回复运行现场，程序独立运行的基本单位正是有这两个基本属性构成的 进程并发执行所需付出的时空开销 创建进程 撤销经常 进程切换 进程——作为资源调度分配的基本单位线程与进程的比较线程具有许多传统进程锁具有的特征 调度的基本单位 进程 进程是作为独立调度和分配的基本单位，因此进程是指能独立运行的基本单位。 每次调度都时都需要进行上下文切换，开销较大 线程 引入线程把线程作为调度和分配的基本单位，因而线程是能够独立运行的基本单位 在线程切换时仅需保存和设置少量寄存器内容，切换代价远低于进程 同一进程中，线程切换不会引起进程切换 从一个进程中的线程切换到另一个进程中的线程时，必然会引起进程切换 并发性 不仅进程之间可以并发执行，而在一个进程中的所有线程也可以并发执行，不同进程中的线程也可以并发执行 拥有资源 进程可以拥有资源，并作为系统中拥有资源的一个基本单位 线程本身并不拥有系统资源，而且仅有一点必不可少的、能保证独立运行的资源 线程除了拥有自己的少量资源外，还允许多个进程共享该进程所拥有的资源 属于同一进程的所有线程都具有相同的地址空间 线程可以访问改地址空间中的每一个虚地址 还可以访问进程所拥有的资源 独立性 同一进程中的不同线程之间的独立性要比不能进程之间的独立性低得多 系统开销 在创建或撤销进程时，系统都要为之分配和回收进程控制块、分配或回收其他资源 支持多处理系统 多处理机系统中，对于传统的进程，单线程进程，不管有多少处理机该进程只能运行在一个处理机上。多线程进程就可以将一个进程中的多个线程分配到多个处理机上 线程状态和线程控制块 线程运行三个状态 执行状态 已获得处理机正在运行 就绪状态 以具备各种执行条件，只需获得CPU便可立即执行 阻塞状态 因某事件受阻而处于暂停状态 线程控制块TCB 每个线程配置一个线程控制块TCB，将所有用于控制和管理线程的信息记录在线程控制块中 线程标识符 一组寄存器 线程运行状态 优先级 线程专有存储区 信号品屏蔽 堆栈指针 多线程操作系统属性 进程是一个可拥有资源的基本单位 多个线程可以并发执行 进程已不是可执行实体 线程的实现线程的实现方式线程已在许多系统中实现，但各系统的实现方式并不完全相同。在有的系统中，特别是一些数据库管理系统，如infomix所实现的是用户级线程； 而另一些系统(如Macintosh和OS/2操作系统)所实现的是内核支持线程；还有一些系统如Solaris操作系统，则同时实现了这两种类型的线程。 内核支持线程KST(Kernel Supported Threads) 在OS中的所有进程，无论是系统进程还是用户进程，都是在操作系统内核的支持下运行的，是与内核紧密相关的。而内核支持线程KST同样也是在内核的支持下运行的，它们的创建、阻塞、撤消和切换等，也都是在内核空间实现的。为了对内核线程进行控制和管理，在内核空间也为每一个内核线程设置了一个线程控制块，内核根据该控制块而感知某线程的存在，并对其加以控制。当前大多数OS都支持内核支持线程。 这种线程实现方式主要有四个主要优点： 在多处理器系统中，内核能够同时调度同一进程中的多个线程并行执行； 如果进程中的一个线程被阻塞了，内核可以调度该进程中的其它线程占有处理器运行，也可以运行其它进程中的线程； 内核支持线程具有很小的数据结构和堆栈，线程的切换比较快，切换开销小； 内核本身也可以采用多线程技术，可以提高系统的执行速度和效率。 用户级线程ULT(User Level Threads) 用户级线程是在用户空间中实现的。对线程的创建、 撤消、同步与通信等功能，都无需内核的支持，即用户级线程是与内核无关的。在一个系统中的用户级线程的数目可以达到数百个至数千个。由于这些线程的任务控制块都是设置在用户空间，而线程所执行的操作也无需内核的帮助，因而内核完全不知道用户级线程的存在。 使用用户级线程方式有许多优点： 线程切换不需要转换到内核空间。 调度算法可以是进程专用的。 用户级线程的实现与OS平台无关，因为对于线程管理的代码是属于用户程序的一部分，所有的应用程序都可以对之进行共享。 而用户级线程方式的主要缺点则在于： 系统调用的阻塞问题。在基于进程机制的OS中，大多数系统调用将使进程阻塞，因此，当线程执行一个系统调用时，不仅该线程被阻塞，而且，进程内的所有线程会被阻塞。而在内核支持线程方式中，则进程中的其它线程仍然可以运行。 在单纯的用户级线程实现方式中，多线程应用不能利用多处理机进行多重处理的优点，内核每次分配给一个进程的仅有一个CPU，因此，进程中仅有一个线程能执行，在该线程放弃CPU之前，其它线程只能等待。 组合方式 有些OS把用户级线程和内核支持线程两种方式进行组合，提供了组合方式ULT/KST 线程。在组合方式线程系统中，内核支持多个内核支持线程的建立、调度和管理，同时，也允许用户应用程序建立、调度和管理用户级线程。 线程的实现 内核支持线程的实现在仅设置了内核支持线程的OS中，一种可能的线程控制方法是，系统在创建一个新进程时，便为它分配一个任务数据区PTDA(Per Task Data Area)，其中包括若干个线程控制块TCB空间， 用户级线程的实现 运行时系统(Runtime System) 所谓“运行时系统”，实质上是用于管理和控制线程的函数(过程)的集合，其中包括用于创建和撤消线程的函数、线程同步和通信的函数，以及实现线程调度的函数等。正因为有这些函数，才能使用户级线程与内核无关。运行时系统中的所有函数都驻留在用户空间，并作为用户级线程与内核之间的接口。 内核控制线程 这种线程又称为轻型进程LWP(Light Weight Process)。每一个进程都可拥有多个LWP，同用户级线程一样，每个LWP都有自己的数据结构(如TCB)，其中包括线程标识符、优先级、状态，另外还有栈和局部存储区等。LWP也可以共享进程所拥有的资源。LWP可通过系统调用来获得内核提供的服务，这样，当一个用户级线程运行时，只须将它连接到一个LWP上，此时它便具有了内核支持线程的所有属性。这种线程实现方式就是组合方式。 线程的创建和终止 线程的创建 应用程序在启动时，通常仅有一个线程在执行，人们把线程称为“初始化线程”，它的主要功能是用于创建新线程。在创建新线程时，需要利用一个线程创建函数(或系统调用)，并提供相应的参数，如指向线程主程序的入口指针、堆栈的大小，以及用于调度的优先级等。在线程的创建函数执行完后，将返回一个线程标识符供以后使用。 线程的终止 当一个线程完成了自己的任务(工作)后，或是线程在运行中出现异常情况而须被强行终止时，由终止线程通过调用相应的函数(或系统调用)对它执行终止操作。但有些线程(主要是系统线程)，它们一旦被建立起来之后，便一直运行下去而不被终止。在大多数的OS中，线程被中止后并不立即释放它所占有的资源，只有当进程中的其它线程执行了分离函数后，被终止的线程才与资源分离，此时的资源才能被其它线程利用。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://blog.yuewei.fun/categories/操作系统/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://blog.yuewei.fun/tags/操作系统/"}]},{"title":"运输层","slug":"运输层","date":"2017-06-03T07:02:11.000Z","updated":"2019-08-15T08:43:44.615Z","comments":true,"path":"2017/06/03/运输层/","link":"","permalink":"http://blog.yuewei.fun/2017/06/03/运输层/","excerpt":"概念 运输层为相互通信的应用进程提供逻辑通信 端口和套接字的意义 无连接的UDP的特点 面向连接的TCP的特点 在不可靠的网络上实现可靠网络的传输原理，停止等待协议和ARQ协议 TCP的滑动窗口、流量控制、拥塞控制和连接管理","text":"概念 运输层为相互通信的应用进程提供逻辑通信 端口和套接字的意义 无连接的UDP的特点 面向连接的TCP的特点 在不可靠的网络上实现可靠网络的传输原理，停止等待协议和ARQ协议 TCP的滑动窗口、流量控制、拥塞控制和连接管理 运输层协议概述 进程之间的通信 从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。 网络层是为主机之间提供逻辑通信；运输层为应用进程之间提供端到端的逻辑通信。 真正进行通信的实体是主机中的进程，两天机器进程在做数据交换，两台主机进行通信就是两天主机中的应用进程互相通信 复用和分用 复用：在发送方不同的应用进程都可以使用同一个运输层协议传输数据 分用：接收方的运输层再剥去报文的首尾部之后把这些数据交付给目的应用进程 UDP：无连接 TCP：面向连接 运输层主要的两个协议 用户数据报协议UDP 在传输数据之前不需要先建立连接，接收方收到UDP报文后不需要给出任何确认 传输控制协议TCP 提供面向连接服务 服务器端使用的端口号 熟知端口号或系统端口号（0~1023） 客户端使用的端口号或短暂端口号（49152~65535） 客户端收到确认之后端口自动释放 用户数据报协议 UDP概念： 无连接，发送不需要建立，结束不需要释放 UDP使用尽最大女里交付：不保证可靠交付， 因此主机不需要维持复杂的连接状态 UDP是面向报文的：发送方的UDP对应用程序叫下来的报文，添加首部后乡下交付IP层，UDP对应用层交下来的报文既不合并也不拆分，只是保留这些报文的边界 无拥塞控制：可以丢数据，但不会慢 支持一对一、一对多、多对一、多对多 首部开销小，只有8个自己（TCP20个字节） UDP首部格式 用户数据包UDP有两个字段： 数据字段 首部字段 只有8个字节 源端口：源端口。在需要对方回信时使用，不需要全为0 目的端口：必须 长度：UDP用户数据报长度，最小值8（仅有首部） 检验和：检测UDP用户数据包在传输中是否有错，有错就丢弃&nbsp; 传输控制协议 TCP 概述 端口号拼接到IP地址构成套接字或插口 套接字socket=(IP地址：端口号) 每一条TCP连接唯一的被通信两个端点（即两个套接字）所确定 TCP连接：=(socket1,socket2) = (IP1:port1),(IP2:poer2) 可靠传输的工作原理TCP 报文段的首部格式TCP面向字节流，但传输的数据单元式报文段。报文段分为首部和数据两部分，而TCP的全部功能都体现在他首部中各个字段的作用TCP报文首部的前20个字节是固定的，后面有4n个字节是根据需要而增加的选项（n是整数）。因此TCP首部的最小长度时20字节 源端口和目的端口 各占2个字节 分别写入源端口号和目的端口号 序号（报文段序号） 占4个字节 范围[0,2的32次方 - 1]，共2的32次方个序列号（4 294 967 296）。 增加到2的32次方-1后，下一个序号就又回到0 序号使用的是mod 2的32次方运算 TCP是面向字节流的。在一个TCP连接中传送的字节流的每一个字节都按序号排序 整个要传送的字节流的起始序号必须在连接建立时设置。 首部中的序号字段值则指的是本报文段所发送的数据的第一个字节的序号 确认号 占四个字节 期望收到对方下一个报文段的第一个数据字节的序号 若确认号 = N， 则表明:到序列号N-1位置的所有数据都已经确认收到 由于序号字段有32位长，可对4GB的数据进行编号。在一般情况下可保证当序号重复使用时，旧序号的数据早已通过网络早已通过网络到达终点 数据偏移 占4位 指出TCP报文段的数据起始处距离TCP报文段的起始处有多远 指出TCP报文段长度（实际意思） 由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的 保留 占6位 保留为后使用，但目前应置为0 紧急URG 当URG=1时，表明紧急指针字段有效，他告诉系统此报文段中有紧急数据，应该尽快处理（优先级高的数据），而不是按原来的排队顺序来传输 确认ACK 仅当ACK=1时确认好字段才有效 当ACK=0时确认好无效 TCP规定在连接建立后所有传送的报文段都必须把ACK设置为1 推送PSH（PuSH） 当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。 PSH = 1 几首方收到PSH的报文段，就立即交付给应用进程而不等到整个缓存都填满了之后再交付 很少使用 复位RST RST = 1 而 ACK = 0时，表明是一个连接请求报文段。 若对方同意，则响应报文段中使用SYN=1 和 ACk = 1 终止（FIN） 释放一个连接 FIN = 1时，表明此报文段发送方的数据已发送完毕，并要求释放运输连接 窗口 占2个字节 值[0, 2的16次方 - 1]之间的整数。 窗口指的是发送报文段的一方接收窗口 窗口值：从本报文段首部中的确认好算起，接收方目前允许对方发送的数据量（字节） 窗口值作为接收方让发送方设置其发送窗口的依据 窗口字段明确指出了现在允许对方返送的数据量。窗口值经常在动态变化 检验和 占2字节 检验和检验的范围包括首部和数据两部分 和UDP用户数据报一样，在计算检验和时，要在TCP报文钱加上12字节的伪首部。 紧急指针 占2字节 紧急指针仅在URG = 1 时才有意义 指出本报文段中的紧急数据的字节数 紧急指针指出了紧急数据的末尾数据的字节数 当窗口为零时也可以发送紧急指针 选项 长度可变 最长可达40字节 当没有使用“选项”时，TCP的首部长度时20个字节 TCP 可靠传输的实现TCP 的流量控制TCP的流量控制利用滑动窗口实现流量控制概念：发送方发送速率不要太快，让接收方来的及接收利用滑动窗口机制可以很方便的在TCP连接上实现对流量的控制 发送方的发送窗口数值不能大于接收方接收窗口给出的数值窗口单位是字节，而不是报文段死锁：A在等待B，B在等待A 解决方案：TCP为每个连接设有一个持续计时器，只要TCP连接的一方收到对方的窗口通知，就启动持续计时器。若持续计时器时间到期，就发送一个零窗口探测报文段（包含一个字节），而对方再确认这个探测报文段时，给出了现在的窗口值。如果任然是0，那么收到这个报文段的一方就重新设置持续计时器，如果不是零，那么死锁就可以打破 TCP的传输效率应用进程把数据传输到发送方缓存后剩下的就是TCP来处理了可以用不同处理机制TCP报文段的发送时机 TCP维持一个变量，等于最大报文段长度MSS，只有缓存中的数据达到MSS字节时就组成一个TCP报文段发送出去 发送发进程来指明要求发送报文段，即TCP支持的推送操作（push） 发送方的一个计时器过期了，这时就把已有缓存数据装入报文段（不能超过最大报文段MSS）发送出去 Nagle算法：发送方把缓存中第一个字节先发出去，其余的缓存起来，当接收到对方第一个字符确认后将缓存中的所有数据组装成一个报文段发送过去，同时随后到达的数据进行缓存，只有得到前一个报文段确认后才会继续发送下一个报文段 规定:当到达的数据已达到发送窗口大小的一半或已达到报文段最大长度时，立即发送下一报文段。这样做就可以提高网络吞吐量 糊涂窗口综合征接收方缓存数据空间较小 让接受方等一段时间，当达到接收方已有充足空间、缓存有一半的空闲空间接收方发出确认报文，并向发送方通知当前窗口大小，发送方也不要发送较小的报文段，把数据积累成足够大的报文段或达到接收方缓存空间一半大小 综上所述：发送方不要发送较小报文段接收方缓存有一小点空间之后就急忙把窗口大小信息通知给发送发 TCP 的拥塞控制TCP 的运输连接管理","categories":[{"name":"计算应网络","slug":"计算应网络","permalink":"http://blog.yuewei.fun/categories/计算应网络/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://blog.yuewei.fun/tags/网络/"}]},{"title":"更新","slug":"更新blog","date":"2017-03-03T06:48:39.000Z","updated":"2019-08-07T09:01:49.412Z","comments":true,"path":"2017/03/03/更新blog/","link":"","permalink":"http://blog.yuewei.fun/2017/03/03/更新blog/","excerpt":"博客内容更新","text":"博客内容更新 新建文章1$ hexo new \"My New Post\" 运行1$ hexo server 或 $hexo s 清空资源文件1$ hexo clean 重新生成资源文件1$ hexo generate 或 $ hexo g 发布文章到github.io1$ hexo deploy 或 hexo d","categories":[{"name":"算法排序","slug":"算法排序","permalink":"http://blog.yuewei.fun/categories/算法排序/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://blog.yuewei.fun/tags/排序/"},{"name":"算法","slug":"算法","permalink":"http://blog.yuewei.fun/tags/算法/"}]}]}