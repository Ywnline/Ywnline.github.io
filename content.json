{"meta":{"title":"Ywnline","subtitle":null,"description":"http://blog.yuewei.fun","author":"Ywnline","url":"http://blog.yuewei.fun","root":"/"},"pages":[{"title":"tags","date":"2019-08-02T07:35:29.000Z","updated":"2019-08-06T06:03:14.576Z","comments":true,"path":"tags/index.html","permalink":"http://blog.yuewei.fun/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-08-02T07:34:41.000Z","updated":"2019-08-06T06:03:12.170Z","comments":true,"path":"categories/index.html","permalink":"http://blog.yuewei.fun/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"操作系统引论","slug":"操作系统引论","date":"2019-08-06T02:38:56.000Z","updated":"2019-08-06T07:51:15.705Z","comments":true,"path":"2019/08/06/操作系统引论/","link":"","permalink":"http://blog.yuewei.fun/2019/08/06/操作系统引论/","excerpt":"操作系统（OS）是计算机上第一层软件，对硬件系统的首次扩充。主要作用管理好这些设备，提高利用率和吞吐量，并为用户和应用进程提供一个简单的接口，便于使用。","text":"操作系统（OS）是计算机上第一层软件，对硬件系统的首次扩充。主要作用管理好这些设备，提高利用率和吞吐量，并为用户和应用进程提供一个简单的接口，便于使用。 操作系统的作用和目标操作系统目标 方便性 未配置OS的需要机器语言 有效性 提高系统资源利用率 提高系统吞吐量：合理组织计算机的工作流程，加速程序运行，缩短运行周期 可扩充性 可扩充性好坏与OS结构十分紧密联系 OS结构发展：无结构···模块化结构···层次结构···微内核结构（可以方便添加新的功能模块） 开放性 遵循世界标准规范，特别是遵循开放系统互连OSI国际标准 操作系统作用 OS作为用户与计算机硬件系统之间的接口 OS处于用户与计算机系统之间，用户通过OS来使用计算机系统 通过命令、系统调用、图标-窗口方式来完成通信 OS作为计算机系统资源的管理者 这些资源分为四大类：处理机、存储器、I/O设备、文件（数据和程序） 处理机 ： 用户分配和控制处理机 存储器 ： 主要负责内存分配和回收 I/O设备： 负责I/O设备的分配（回收）操作 文件管理： 用于实现对文件的存取、共享和保护 OS 实现了对计算机资源的抽象 完全无软件的计算机系统（裸机） 裸机上铺设I/O设备称为扩充器或虚拟机 I/O 设备实现对计算机硬件操作的第一层抽象 文件管理实现对计算机硬件操作的第二层抽象（功能更强的虚拟机） 推动操作系统发展的主要动力 不断提高计算机的利用率 方便用户 硬件的不断更新 计算机体系结构的不断发展 不断提出新的应用需求 操作系统的发展过程未配置操作系统的计算机系统 人工操作方式 人工操作穿孔的纸带（卡片） 缺点: 用户独占全机 CPU等待人工操作 人工操作方式严重降低了计算机利用率 脱机输入/输出方式 将原有纸带装入纸带输入机，在一台外围机的控制下把纸袋上的数据（程序）放到磁盘上 有点： 减少CPU空闲时间 提高I/O的速度 单道批处理系统 单道批处理系统的处理流程 监督程序将磁带上的作业一个一个顺序执行 单道批处理系统缺点 系统中资源得不到重复利用 多道批处理系统 多道批处理系统处理流程 用户提交作业在外存上，排成一个队列（后备队列），作业调度根据一定算法，一次取多个调入内存，减少CPU的空当时间 多道批处理系统的缺点 资源利用率高 系统吞吐量达 CPU和其他资源保持“忙碌”状态 仅当作业完成、或运行不下去时在进行切换，系统开销小 平均周转时间长 无交互能力 多道批处理系统需要解决的问题 问题： 处理机挣用问题 内存分配和保护问题 I/O 设备分配问题 文件的组织和管理问题 作业管理问题 用户与系统的接口问题 分时系统 分时系统的引入 人——机交互 共享主机 分时系统是指，在一台计算机上连接多个鼠标、显示器的终端所组成的系统，该系统运行多个用户同时访问，共享主机资源 分时系统的关键问题 及时接受 及时处理 分时系统的特新 多路性 独立性 及时性 交互性 实时系统 时间作为关键参数，收到某些信号“及时”、“实时”的反响 实时系统的类型 工业控制系统 信息查询系统 多媒体系统 嵌入式系统 实时任务类型 周期性和非周期性实时任务 硬实时任务和软实时任务 （必须小于截至截止时间，不一定小于截止时间） 实时系统与分时系统比较 多路性 独立性 及时性 交互性 可靠性 微机操系统作发展史 单用户单任务操作系统 单用户多任务操作系统 多用户多任务操作系统 并发并发和并行 并行 两个或多个事件在同一时刻运行 并发 两个或多个事件在同一时间间隔内发生 引入进程在属于同一个计算程序和I/O程序之间只能顺序执行，即只有在计算程序执行告一段落后，才允许I/O程序执行，反之在执行I/O操作时计算程序也不能执行。但在为计算程序和I/O程序分别建立一个进程后两个进程可以并发执行 进程 在系统中能够独立运行并作为资源分配的基本单位，它是由一组机器指令、数据、堆栈等组成的，是以独立的活动实体。多个进程之间可以并发执行和交换信息。 共享 共享与操作环境下的共享（含义不一致） 共享 某种资源能被大家使用 操作系统环境下的共享（资源复用） 指操作系统中的资源可供内存中多个并发执行的进程共同使用 互斥共享方式系统中的某些资源虽然可以提供给多个进程（线程）使用，但在规定的时间内只有一个进程访问资源，为此建立了互斥访问 同时访问方式系统中有一类资源允许同一时间由多个进程“同时”访问 并发和共享是多用户（多任务）OS的两个最基础的特征。 虚拟时分复用技术广泛利用时分复用技术来实现虚拟处理机、虚拟设备等，是资源利用率提高。原因：利用某设备为一个用户服务空闲时间又转去为其他用户服务，使得设备得到充分利用。 虚拟处理技术 虚拟设备技术 空分复用技术将一个频率范围比较宽的信道划分为多个窄的信道（称为频带），其中的任何一个频带仅供一对用户通话。 操作系统的主要功能处理机管理功能 进程控制 进程控制的主要功能也就是作为穿件进程、撤销（终止）已接收的进程，控制进程在运行时状态的转换 进程同步 进程互斥方式 访问临界资源时采用互斥：为每一个临界资源配置一把锁（W），当锁打开时才可以访问，关闭时禁止访问 进程同步 多个进程去做一件事情，有同步机构对他们执行次序加以协调：信号量机制 进程通信 由源进程利用发送消息命令直接将消息挂载到目标进程得到消息队列上，由目标进程利用接收命令消息队列中取出消息 调度 作业调度 任务是从后备队列中按照一定的算法选择处若干个作业，为他们分配运行所需资源，再讲这些作业调入内存后， 分别为他们建立进程，使它们成为可能获得处理机的就绪，并将它们插入到就绪队列中 进程调度 从进程的就绪队列中按照一定的算法选出一个进程，将处理机分配给他，并为他设置运行现场，使其投入执行 存储器管理功能功能：为多道程序的运行提供良好的环境，提高存储器利用率，方便用户使用，从逻辑上扩充内存。 内存分配回收 为每道程序分配内存空间，使他们“各得其所” 提高存储器利用率，减少不可用的内存空间 允许正在运行的程序申请附加内存空间，适应程序动态增长 OS 内存分配动态和静态两种方式： 静态 每个作业的内存空间在装入时确定，运行期间不能申请新的空间，不能在内存中移动 动态 每个作业的内存空间在装入时确定，运行期间可以继续申请新的空间，以适应程序数据的动态增长，运行在作业内存中移动 内存保护 确保每道用户程序都仅能在自己的空间内运行，彼此互不干扰 觉不允许用户程序访问操作系统的程序和数据，也不允许用户程序转移到非共享的其他用户程序中执行 内存保护机制设置两个界限寄存器 对每条指令所要访问的地址进行检查，如发生越界，发出越界中断请求，停止程序的执行 地址映射 逻辑空间中的逻辑地址转换为空间中与之对应的物理地址 内存扩充 借助于虚拟存储技术，从逻辑上扩充内存容量，让用户感觉到内存容量比实际大的多，让用户程序能并发运行 请求调入功能 置换功能：将不需要挂起至硬盘，需要的转入内存 设备管理功能","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://blog.yuewei.fun/categories/操作系统/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://blog.yuewei.fun/tags/操作系统/"}]},{"title":"Linux","slug":"Linux","date":"2019-08-04T05:09:52.000Z","updated":"2019-08-05T01:26:43.586Z","comments":true,"path":"2019/08/04/Linux/","link":"","permalink":"http://blog.yuewei.fun/2019/08/04/Linux/","excerpt":"LINUX常用命令（基础） man 对你熟悉或不熟悉的命令提供帮助解释 eg:man ls 就可以查看ls相关的用法","text":"LINUX常用命令（基础） man 对你熟悉或不熟悉的命令提供帮助解释 eg:man ls 就可以查看ls相关的用法 注：按q键或者ctrl+c退出，在linux下可以使用ctrl+c终止当前程序运行。 ls 查看目录或者文件的属*，列举出任一目录下面的文件 eg: ls /usr/man ls -l d表示目录(directory)，如果是一个”-“表示是文件，如果是l则表示是一个连接文件(link) 表示文件或者目录许可权限.分别用可读(r)，可写(w)，可运行(x)。 cp 拷贝文件 eg: cp filename1 filename2 //把filename1拷贝成filename2 cp 1.c netseek/2.c //将1.c拷到netseek目录下命名为2.c rm 删除文件和目录 eg: rm 1.c //将1.c这个文件删除 mv 移走目录或者改文件名 eg: mv filename1 filename2 //将filename1 改名为filename2 mv qib.tgz ../qib.tgz //移到上一级目录 cd 改变当前目录 pwd 查看当前所在目录完整路径 eg: pwd //查看当前所在目录路径 cd netseek //进入netseek这个目录 cd //退出当前目录 cat，more命令 将某个文件的内容显示出来。两个命令所不同的是:cat把文件内容一直打印出来，而 more则分屏显示 eg; cat&gt;1.c //就可以把代码粘帖到1.c文件里，按ctrl+d 保存代码。 cat 1.c 或more 1.c //都可以查看里面的内容。 gcc -o 1 1.c //将1.c编译成.exe文件，我们可以用此命编译出代码。 chmod 命令 权限修改 用法：chmod 一位8进制数 filename。 eg: chmod u+x filenmame //只想给自己运行，别人只能读 //u表示文件主人， g 表示文件文件所在组。 o 表示其他人 ;r 表可读，w 表可写，x 表可以运行 chmod g+x filename //同组的人来执行 clear，date命令 clear:清屏，相当与DOS下的cls;date:显示当前时间。 mount 加载一个硬件设备 用法:mount [参数] 要加载的设备 载入点 eg: mount /dev/cdrom cd /mnt/cdrom //进入光盘目录 su 在不退出登陆的情况下，切换到另外一个人的身份 用法: su -l 用户名(如果用户名缺省，则切换到root状态) eg:su -l netseek (切换到netseek这个用户，将提示输入密码) whoami，whereis，which，id //whoami:确认自己身份 //whereis:查询命令所在目录以及帮助文档所在目录 //which:查询该命令所在目录(类似whereis) //id:打印出自己的UID以及GID。(UID:用户身份唯一标识。GID:用户组身份唯一标识。每一个用户只能有一个唯一的UID和 GID) eg: whoami //显示你自已登陆的用户名 whereis bin 显示bin所在的目录，将显示为：/usr/local/bin which bin grep，find grep:文本内容搜索;find:文件或者目录名以及权限属主等匹配搜索 eg: grep success * /*查找当前目录下面所有文件里面含有success字符的文件 kill 可以杀死某 个正在进行或者已经是dest状态的进程 eg; ps ax passwd 可以设置口令 history 用户用过的命令 eg: history //可以显示用户过去使用的命令 !! 执行最近一次的命令 mkdir命令 eg: mkdir netseek //创建netseek这个目录 tar 解压命令 eg: tar -zxvf nmap-3.45.tgz //将这个解压到nmap-3.45这个目录里 finger 可以让使用者查询一些其他使用者的资料 eg: finger //查看所用用户的使用资料 finger root //查看root的资料 本文讲解了Linux创建文件命令的方法 ,希望对您的学习有所帮助。 创建文件夹 mkdir aaa mkdir -p aaa 创建文件命令 vi foo.txt emacs foo.txt echo “aaaa” &gt; foo.txt cat &gt; foo.txt 清除命令 foo.txt mkdir /home/u1 创建文件夹/home/u1 chown oracle /home/u1 表示改变目录所有者为oracle账户; chgrp dba /home/u1 改变/home/u1目录为dba所有; chmod 755 /home/u1 表示oracle账户对/home/u1目录有755权限; rmdir /home/u1 表示删除/home/u1目录 hostname可以查看linux的计算机名; whoami可以查看当前用户; pwd显示当前路径; df查看系统的硬件信息 ls -lrt l表示显示详细列表，-t表示按时间排序,-r反向排序 cat orcl_ora_3436.trc|grep bucket 以下查看相关文件内容: more /etc/oratab cat /etc/passwd cat /etc/group 以上是Linux创建文件命令的方法。 linux中创建文件用touch 例如：touch 1.txt 删除文件用rm 例如：rm -f 1.txt 创建目录用mkdir 例如：mkdir daiyuanqi 删除空目录用rmdir 例如：rmdir daiyuanqi （有东西的目录不能删） 删除装有东西的目录就用rm -rf 例如rm -rf XXX","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://blog.yuewei.fun/tags/服务器/"}]},{"title":"CentOS7安装过程","slug":"CentOS7安装过程","date":"2019-08-04T05:01:32.000Z","updated":"2019-08-04T05:06:58.256Z","comments":true,"path":"2019/08/04/CentOS7安装过程/","link":"","permalink":"http://blog.yuewei.fun/2019/08/04/CentOS7安装过程/","excerpt":"安装UltraISO官网搜索next 从U盘安装CentOS7.3教程 准备工作: 一台没系统的普通电脑 u盘一个（大于1G，最小安装的话不超过1G，根据选择系统大小匹配U盘即可） CentOS7.3 iso文件一个 UltraISO工具","text":"安装UltraISO官网搜索next 从U盘安装CentOS7.3教程 准备工作: 一台没系统的普通电脑 u盘一个（大于1G，最小安装的话不超过1G，根据选择系统大小匹配U盘即可） CentOS7.3 iso文件一个 UltraISO工具 制作U盘 使用UltraISO工具 文件-》打开 选择你的ISO文件 先使用UltraISO刻录镜像至U盘内（PS:刻录的时候隐藏启动分区可以选成无，里面的packages文件夹可以删除，这个文件夹是没什么用的，而且大小挺大的，因为安装的时候有镜像在U盘内） 开始安装 把制作好的U盘插入需要安装Linux的电脑，把电脑的第一启动方式设置为U盘启动之后 会进入选择安装界面 接下来就是最重要的地方，关系着你能不能安装成功 我就是在这里卡了好久 先移动到第二项test &amp;Install 然后按e键编辑路径 将vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\\x207\\x20x86_64 quiet改成vmlinuz initrd=initrd.img linux dd quiet ctrl+x 然后就能在显示出的列表中 查看你的硬盘信息，很清晰就能知道哪一个是你的U盘（一般显示的几个 格式为NTFS的都是你电脑自身的盘符，另外的一个就是你的U盘，记下你的U盘的盘符名字 我的就是sda4）使用ctrl+alt+del 重新启动电脑，重复上面的步骤 这一次 将vmlinuz initrd=initrd.img inst.stage2=hd:LABEL=CentOS\\x207\\x20x86_64 quiet改成vmlinuz initrd=initrd.img inst.stage2=hd:/dev/sda4（你自己的U盘盘符） quiet ctrl+x 等待安装程序启动，进行CentOS的安装 Linux引导安装 选择中文安装 选择时区，设置时间，能够在网络与主机里面连接wifi之后 在时间设置里面使用网络时间 选择软件的安装源 U盘安装一般是默认选择 一般是Packages文件夹，不用管 比较常用的是最小化安装（安装快，只有命令行操作） 带有桌面的安装（一些配置和使用都可以图形化操作，较好用） 服务器版安装（特定组件可以省掉自己安装的很多问题），这里选择最小化安装，另外可以根据自己的需要从右面选择部分组件安装 刚开始接触Linux的朋友建议使用GHOME图形操作界面，好上手 网络和主机名里面配置网络信息 我这里是用的虚拟机安装 所以安装位置只能选择虚拟机，但是在真机安装的时候 需要选择具体的安装位置，如果之前电脑用过WIndows 硬盘已经分区了 需要进行磁盘释放，之后选择安装位置 全部信息确认完毕之后 就可以开始安装了 在这里可以新建用户 设置root操作 等待下方安装进度完成 之后就能进入Linux系统了 解决CentOS7 用U盘 无法进入安装界面 这是用uefi方式启动的CentOS的版本是1708 首先按”e”键进入编辑界面将inst.stage2=hd:LABEL=CentOS\\x207\\x20x86_64 改为linux dd 按”ctrl + x”执行 然后找到那个驱动器 这里是sdd4 重新进入引导界面，修改以下信息 从inst.stage2=hd:开始，修改为/dev/sdd4 (这是自己的U盘位置) 按”ctrl + x” 稍等片刻，就可以安装CentOS7了","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://blog.yuewei.fun/tags/服务器/"}]},{"title":"策略模式","slug":"策略模式","date":"2019-08-03T08:33:22.000Z","updated":"2019-08-03T08:38:21.150Z","comments":true,"path":"2019/08/03/策略模式/","link":"","permalink":"http://blog.yuewei.fun/2019/08/03/策略模式/","excerpt":"概述策略模式定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户","text":"概述策略模式定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户 使用场景需要有一系列不同的算法，这些算法完成的工作是同样的，只是实现不同，强调以相同的方式调用所有的算法，减少算法类和使用算法类之间的耦合 优势使代码结构清晰，便于维护，简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试 每个算法的修改都不会影响到其他的算法 实际应用场景商场商品价格计算，其中涉及到的有商品的单价，个数，折扣 折扣的策略有： 固定折扣 满减 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546type CashSuper interface &#123; Accept(float64) float64&#125;//CashNormal normal strategytype CashNormal struct&#123;&#125;func (normal CashNormal) Accept(money float64) float64 &#123; return money&#125;//CashRebatetype CashRebate struct &#123; moneyRebate float64&#125;func (re CashRebate) Accept(money float64) float64 &#123; return money * re.moneyRebate&#125;//CashReturntype CashReturn struct &#123; moneyCondition float64 moneyReturn float64&#125;func (re CashReturn) Accept(money float64) float64 &#123; if money &gt;= re.moneyCondition &#123; return money - re.moneyReturn &#125; return money&#125; type CashContext struct &#123; strategy CashSuper&#125;func NewCashContext(acceptType string) (cashFactory CashContext) &#123; switch acceptType &#123; default: fmt.Println(&quot;wrong type&quot;) case &quot;normal&quot;: cashFactory.strategy = CashNormal&#123;&#125; case &quot;0.8rebate&quot;: cashFactory.strategy = CashRebate&#123;moneyRebate: 0.8&#125; case &quot;300return100&quot;: cashFactory.strategy = CashReturn&#123;300, 100&#125; &#125; return&#125;func (cashFactory CashContext) Accept(money float64) float64 &#123; return cashFactory.strategy.Accept(money)&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.yuewei.fun/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.yuewei.fun/tags/设计模式/"}]},{"title":"简单工厂模式","slug":"设计模式学习-简单工厂模式","date":"2019-08-03T08:25:10.000Z","updated":"2019-08-03T08:38:09.063Z","comments":true,"path":"2019/08/03/设计模式学习-简单工厂模式/","link":"","permalink":"http://blog.yuewei.fun/2019/08/03/设计模式学习-简单工厂模式/","excerpt":"概述工厂模式是对象的生产器，解耦用户对具体的依赖。通过封闭、继承、多态把程序的耦合度降低，使程序更加灵活，容易修改，并易于复用。简单工厂模式中，各种运算方法类实现了运算接口，在业务上如果想添加一种算法方法，只需要增加一个实现接口的类，并且在工厂的类型中添加一个判断。这种设计适合用于业务逻辑并不多的情况，如果业务逻辑非常多，那么工作累就是一个很长的swuth…case结构这时候使用工厂模式会比较合适。","text":"概述工厂模式是对象的生产器，解耦用户对具体的依赖。通过封闭、继承、多态把程序的耦合度降低，使程序更加灵活，容易修改，并易于复用。简单工厂模式中，各种运算方法类实现了运算接口，在业务上如果想添加一种算法方法，只需要增加一个实现接口的类，并且在工厂的类型中添加一个判断。这种设计适合用于业务逻辑并不多的情况，如果业务逻辑非常多，那么工作累就是一个很长的swuth…case结构这时候使用工厂模式会比较合适。 主要类 base - interface concreteA - concrete class A concreteB - concrete class B factory - in: choice; out: base 优势工厂类中包含了必要的逻辑判断，根据客户端的选择条件实例化相应的类，对于客户端来说，去除了与具产品的依赖 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*设计一个计算器*///Operation 操作接口type Operation interface &#123; SetNumber(float64, float64) GetResult() float64&#125;//BaseOperation 基础类type BaseOperation struct &#123; Operation NumberA float64 NumberB float64&#125;func (bo *BaseOperation) SetNumber(numberA, numberB float64) &#123; bo.NumberA = numberA bo.NumberB = numberB&#125;//OperationAdd 加法运算type OperationAdd struct &#123; BaseOperation&#125;func (oa OperationAdd) GetResult() float64 &#123; return oa.NumberA + oa.NumberB&#125;//OperationSub 减法运算类type OperationSub struct &#123; BaseOperation&#125;func (os OperationSub) GetResult() float64 &#123; return os.NumberA - os.NumberB&#125; //OperationFactory 工厂类type OperationFactory struct&#123;&#125;func (of OperationFactory) CreateOperation(oper string) Operation &#123; switch oper &#123; default: return nil case &quot;+&quot;: return new(OperationAdd) case &quot;-&quot;: return new(OperationSub) &#125;&#125;//OperationUsage 工厂操作func OperationUsage() &#123;factory := new(OperationFactory)operation := factory.CreateOperation(&quot;+&quot;)operation.SetNumber(1, 2)fmt.Printf(&quot;this is add operation, 1+2=%v\\n&quot;, operation.GetResult())operation = factory.CreateOperation(&quot;-&quot;)operation.SetNumber(2, 1)fmt.Printf(&quot;this is sub operation, 2-1=%v\\n&quot;, operation.GetResult())&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*设计一个工厂来生产各种厂商的手机其中初始的厂商有小米，苹果，华为*///Phone interfacetype Phone interface &#123; ShowBrand()&#125;//IPhone appletype IPhone struct &#123;&#125;func (phone IPhone) ShowBrand() &#123; fmt.Println(&quot;[Phone Brand]: Apple&quot;)&#125;//HPhone huaweitype HPhone struct &#123;&#125;func (phone HPhone) ShowBrand() &#123; fmt.Println(&quot;[Phone Brand]: Huawei&quot;)&#125;//XPhone xiaomitype XPhone struct &#123;&#125;func (phone XPhone) ShowBrand() &#123; fmt.Println(&quot;[Phone Brand]: Xiaomi&quot;)&#125;type PhoneFactory struct&#123;&#125;func (factory PhoneFactory) CreatePhone(brand string) Phone &#123; switch brand &#123; default: return nil case &quot;HW&quot;: return new(HPhone) case &quot;XM&quot;: return new(XPhone) case &quot;PG&quot;: return new(IPhone) &#125;&#125;func PhoneUsage() &#123; factory := PhoneFactory&#123;&#125; phone := factory.CreatePhone(&quot;HW&quot;) phone.ShowBrand()&#125; 12345678func main() &#123; OperationUsage() PhoneUsage()&#125;result :this is add operation, 1+2=3this is sub operation, 2-1=1[Phone Brand]: Huawei","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.yuewei.fun/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.yuewei.fun/tags/设计模式/"}]},{"title":"运输层","slug":"运输层","date":"2019-08-03T07:02:11.000Z","updated":"2019-08-06T06:03:08.491Z","comments":true,"path":"2019/08/03/运输层/","link":"","permalink":"http://blog.yuewei.fun/2019/08/03/运输层/","excerpt":"概念 运输层为相互通信的应用进程提供逻辑通信 端口和套接字的意义 无连接的UDP的特点 面向连接的TCP的特点 在不可靠的网络上实现可靠网络的传输原理，停止等待协议和ARQ协议 TCP的滑动窗口、流量控制、拥塞控制和连接管理","text":"概念 运输层为相互通信的应用进程提供逻辑通信 端口和套接字的意义 无连接的UDP的特点 面向连接的TCP的特点 在不可靠的网络上实现可靠网络的传输原理，停止等待协议和ARQ协议 TCP的滑动窗口、流量控制、拥塞控制和连接管理 运输层协议概述 进程之间的通信 从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。 网络层是为主机之间提供逻辑通信；运输层为应用进程之间提供端到端的逻辑通信。 真正进行通信的实体是主机中的进程，两天机器进程在做数据交换，两台主机进行通信就是两天主机中的应用进程互相通信 复用和分用 复用：在发送方不同的应用进程都可以使用同一个运输层协议传输数据 分用：接收方的运输层再剥去报文的首尾部之后把这些数据交付给目的应用进程 UDP：无连接 TCP：面向连接 运输层主要的两个协议 用户数据报协议UDP 在传输数据之前不需要先建立连接，接收方收到UDP报文后不需要给出任何确认 传输控制协议TCP 提供面向连接服务 服务器端使用的端口号 熟知端口号或系统端口号（0~1023） 客户端使用的端口号或短暂端口号（49152~65535） 客户端收到确认之后端口自动释放 用户数据报协议 UDP概念： 无连接，发送不需要建立，结束不需要释放 UDP使用尽最大女里交付：不保证可靠交付， 因此主机不需要维持复杂的连接状态 UDP是面向报文的：发送方的UDP对应用程序叫下来的报文，添加首部后乡下交付IP层，UDP对应用层交下来的报文既不合并也不拆分，只是保留这些报文的边界 无拥塞控制：可以丢数据，但不会慢 支持一对一、一对多、多对一、多对多 首部开销小，只有8个自己（TCP20个字节） UDP首部格式 用户数据包UDP有两个字段： 数据字段 首部字段 只有8个字节 源端口：源端口。在需要对方回信时使用，不需要全为0 目的端口：必须 长度：UDP用户数据报长度，最小值8（仅有首部） 检验和：检测UDP用户数据包在传输中是否有错，有错就丢弃&nbsp; 传输控制协议 TCP 概述 端口号拼接到IP地址构成套接字或插口 套接字socket=(IP地址：端口号) 每一条TCP连接唯一的被通信两个端点（即两个套接字）所确定 TCP连接：=(socket1,socket2) = (IP1:port1),(IP2:poer2) 可靠传输的工作原理TCP 报文段的首部格式TCP面向字节流，但传输的数据单元式报文段。报文段分为首部和数据两部分，而TCP的全部功能都体现在他首部中各个字段的作用TCP报文首部的前20个字节是固定的，后面有4n个字节是根据需要而增加的选项（n是整数）。因此TCP首部的最小长度时20字节 源端口和目的端口 各占2个字节 分别写入源端口号和目的端口号 序号（报文段序号） 占4个字节 范围[0,2的32次方 - 1]，共2的32次方个序列号（4 294 967 296）。 增加到2的32次方-1后，下一个序号就又回到0 序号使用的是mod 2的32次方运算 TCP是面向字节流的。在一个TCP连接中传送的字节流的每一个字节都按序号排序 整个要传送的字节流的起始序号必须在连接建立时设置。 首部中的序号字段值则指的是本报文段所发送的数据的第一个字节的序号 确认号 占四个字节 期望收到对方下一个报文段的第一个数据字节的序号 若确认号 = N， 则表明:到序列号N-1位置的所有数据都已经确认收到 由于序号字段有32位长，可对4GB的数据进行编号。在一般情况下可保证当序号重复使用时，旧序号的数据早已通过网络早已通过网络到达终点 数据偏移 占4位 指出TCP报文段的数据起始处距离TCP报文段的起始处有多远 指出TCP报文段长度（实际意思） 由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的 保留 占6位 保留为后使用，但目前应置为0 紧急URG 当URG=1时，表明紧急指针字段有效，他告诉系统此报文段中有紧急数据，应该尽快处理（优先级高的数据），而不是按原来的排队顺序来传输 确认ACK 仅当ACK=1时确认好字段才有效 当ACK=0时确认好无效 TCP规定在连接建立后所有传送的报文段都必须把ACK设置为1 推送PSH（PuSH） 当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。 PSH = 1 几首方收到PSH的报文段，就立即交付给应用进程而不等到整个缓存都填满了之后再交付 很少使用 复位RST RST = 1 而 ACK = 0时，表明是一个连接请求报文段。 若对方同意，则响应报文段中使用SYN=1 和 ACk = 1 终止（FIN） 释放一个连接 FIN = 1时，表明此报文段发送方的数据已发送完毕，并要求释放运输连接 窗口 占2个字节 值[0, 2的16次方 - 1]之间的整数。 窗口指的是发送报文段的一方接收窗口 窗口值：从本报文段首部中的确认好算起，接收方目前允许对方发送的数据量（字节） 窗口值作为接收方让发送方设置其发送窗口的依据 窗口字段明确指出了现在允许对方返送的数据量。窗口值经常在动态变化 检验和 占2字节 检验和检验的范围包括首部和数据两部分 和UDP用户数据报一样，在计算检验和时，要在TCP报文钱加上12字节的伪首部。 紧急指针 占2字节 紧急指针仅在URG = 1 时才有意义 指出本报文段中的紧急数据的字节数 紧急指针指出了紧急数据的末尾数据的字节数 当窗口为零时也可以发送紧急指针 选项 长度可变 最长可达40字节 当没有使用“选项”时，TCP的首部长度时20个字节 TCP 可靠传输的实现TCP 的流量控制TCP的流量控制利用滑动窗口实现流量控制概念：发送方发送速率不要太快，让接收方来的及接收利用滑动窗口机制可以很方便的在TCP连接上实现对流量的控制 发送方的发送窗口数值不能大于接收方接收窗口给出的数值窗口单位是字节，而不是报文段死锁：A在等待B，B在等待A 解决方案：TCP为每个连接设有一个持续计时器，只要TCP连接的一方收到对方的窗口通知，就启动持续计时器。若持续计时器时间到期，就发送一个零窗口探测报文段（包含一个字节），而对方再确认这个探测报文段时，给出了现在的窗口值。如果任然是0，那么收到这个报文段的一方就重新设置持续计时器，如果不是零，那么死锁就可以打破 TCP的传输效率应用进程把数据传输到发送方缓存后剩下的就是TCP来处理了可以用不同处理机制TCP报文段的发送时机 TCP维持一个变量，等于最大报文段长度MSS，只有缓存中的数据达到MSS字节时就组成一个TCP报文段发送出去 发送发进程来指明要求发送报文段，即TCP支持的推送操作（push） 发送方的一个计时器过期了，这时就把已有缓存数据装入报文段（不能超过最大报文段MSS）发送出去 Nagle算法：发送方把缓存中第一个字节先发出去，其余的缓存起来，当接收到对方第一个字符确认后将缓存中的所有数据组装成一个报文段发送过去，同时随后到达的数据进行缓存，只有得到前一个报文段确认后才会继续发送下一个报文段 规定:当到达的数据已达到发送窗口大小的一半或已达到报文段最大长度时，立即发送下一报文段。这样做就可以提高网络吞吐量 糊涂窗口综合征接收方缓存数据空间较小 让接受方等一段时间，当达到接收方已有充足空间、缓存有一半的空闲空间接收方发出确认报文，并向发送方通知当前窗口大小，发送方也不要发送较小的报文段，把数据积累成足够大的报文段或达到接收方缓存空间一半大小 综上所述：发送方不要发送较小报文段接收方缓存有一小点空间之后就急忙把窗口大小信息通知给发送发 TCP 的拥塞控制TCP 的运输连接管理","categories":[{"name":"计算应网络","slug":"计算应网络","permalink":"http://blog.yuewei.fun/categories/计算应网络/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://blog.yuewei.fun/tags/网络/"}]},{"title":"初级算法学习步骤","slug":"初级算法学习步骤","date":"2019-08-03T06:51:05.000Z","updated":"2019-08-03T06:55:44.775Z","comments":true,"path":"2019/08/03/初级算法学习步骤/","link":"","permalink":"http://blog.yuewei.fun/2019/08/03/初级算法学习步骤/","excerpt":"算法可以说是解决问题的步骤。按常理来说学习算法要先掌握一定的数据结构。但因为数组也是一大数据结构，而且也是非常常用的东西，所以在最初，做一些用数组解决的问题（其实java里的数据结构也都是基于数组和类来实现各种数据结构）。","text":"算法可以说是解决问题的步骤。按常理来说学习算法要先掌握一定的数据结构。但因为数组也是一大数据结构，而且也是非常常用的东西，所以在最初，做一些用数组解决的问题（其实java里的数据结构也都是基于数组和类来实现各种数据结构）。 比如一维数组里：计算两个数组的交集，用数组实现约瑟夫环等等；二维数组里（平面坐标初级）：扫雷，边缘检测问题，生命游戏等等。之后进行对数据结构的掌握，会了常用数据结构之后，就可以进行深入的算法研究了。所以这里的建议的顺序是：熟习数组相关操作熟习字符串相关操作认识基础数据结构：线性表、顺序表、链表、栈、队列、树、哈希表、图等。并且自己实现以上数据结构掌握使用提供的数据结构API。排序算法、查找算法。四个基本算法思想：穷举，递推，递归，概率。数学问题，数论问题，数据结构问题，几何问题，字符串问题，大数运算问题。五大常用算法：分治、动态规划（DP），贪心，回溯，分支界定。多看算法题和算法书。 详细内容注：这里都是用java语言作为例子解答代码进行讲解，同时附带的也都是java的api使用说明，但其实算法对语言依赖性不大，重要的是思想。本文提供给大家一个学习方案作为参考。 数组内容：熟习数组的常用操作，可以做一些基础题，可以上leetcode或者别的算法题网站，刷掉初级算法题库里的数组10几个题目，这样对一维和二维数组的掌握灵活度就比较高了。一个比较典型的二维数组逻辑题目：旋转二维数组：给定一个n×n的二维矩阵表示一个图像，输出将图像旋转90度的样子。（不要用另一个矩阵来旋转）题目具体内容点击标题可以进去查看。其他数组例题：两个数组的交集，数组实现约瑟夫环，简易扫雷，生命游戏等等。其他数组的操作大家可以自行去看看别的题，锻炼一下数组的运用思想。 字符串内容：字符串的操作，比如回文串判定、字符串翻转等等。同样建议上题库做一些相应练习。在java里对应的API：string，stringbuilder，stringbuffer。 数据结构此章内容具体参照：java数据结构和他的API内容：这一部分需要自己先去学习一遍数据结构，然后自己写出来。掌握之后，再去查看api文档，最后学会如何使用api里的数据结构写算法，下面介绍的主要是api的对应方式。1、基础数组、线性表：（1）数组：API：Arrays。（2）线性表：API：ArrayList。2、链表：链表是以节点类为基础的，每个节点类有一个成员变量是下一个节点。API：LinkedList。3、集合（java）：API：Collections。这个接口提供了很多常用方法，具体如何使用可以参照帮助文档。4、向量：（可增长数组）API：Vector接口提供方法与数组类似，具体查看API帮助手册。5、栈：自己先基于数组去实现。API：Stack接口提供查看，移除，压入，查找，判空操作6、队列、双端队列、优先队列：（1）队列：API：Queue。（2）双端队列：API：Deque。（3）优先队列： API：PriorityQueue档。7、哈希表（映射表）：API：（1）Hashmap提供了键—值对应的功能。（2）TreeMap提供了可排序的映射表。8、树：树没有api，可以用上面学过的东西去实现它。9、图：图也是没有api的，用之前学过的结构可以构造。 排序内容：在排序里，需要了解这九大排序算法：1、冒泡排序：每两个交换，每轮吧最大的放后面；2、选择排序：每轮选出最大的放后面；3、插入排序：一个线性表，一开始只有一个元素，加一个排一个；4、希尔排序：5、快速排序：6、堆排序：7、合并排序：8、基数排序：9、计数排序： 查找这个阶段要了解到查找算法在平时的应用，最基础的是直接查找和二分查找，但是有时候在不同场景会有一些优化。1、二分法：对排序好的数组用，Collections提供了此方法2、二分法的各种优化搜索：3、数据结构中的查找：（1）顺序表：同数组，序号或者关键字顺序、二分查找。（2）链表：关键字查找，只能一个个往后找，返回引用。（3）树：树或者二叉树遍历一个个找，二叉搜索树可以根据大小找，原理和二分法一样。平衡二叉树同而搜索树，红黑树效率高。（4）图：深度优先遍历查找。 4个基本算法思想此章节具体参照：4个基本算法思想：穷举、递推、递归、概率内容：这4个基本算法思想是解决基础问题的很实用的方法。这里开始其实就已经是把所有需要的知识准备好了，之后就要开始解题了。1、穷举：暴力破解，n层for循环。枚举每一种可能。2、递推：简单的动态规划，根据递推公式，累加。3、普通递归：化解问题逐渐变小（从n到1）4、概率：使用random数量足够大的时候，得到近似结果。 数学问题，数论问题，数据结构问题，几何问题，字符串问题，大数运算问题：内容：这一块需要了解的是零散问题的应用。每一块我举几个例子，推荐大家还是上刷题网站吧零散的题给刷掉，不推荐直接做各个算法难题，先做这些零散题会对之后系统做算法有一些帮助。以下我诺列一些题目，大家可以自己查查，刷题网站上也有。1、数学问题：罗马数字转换Math函数的应用（自行查看api帮助文档）。保留小数点的操作：例如String.format（“%.2f”,string）2、数据结构问题：约瑟夫环：具体点击这里括号匹配：具体点击这里链表排序、最短路径等等。3、数论问题：素数、完全数为代表的问题。4、几何问题：java里有API：抽象类shape——具体类line2d，Point2d提供了一些集合方法。5、大数运算问题：API：BigInteger，提供加减乘除模，大小比较，转化等运算。6、字符串问题：API：String大致包含这些方法：是否包含，比较（可不考虑大小写），第一次出现索引（前后），两个字符串的某个区域是否相等（regionmatches），replace替换，split（[，]）分割，substring删减，tochararray变成字符数组，tolow/toup，trim忽略前后空白，valueof把别的转换成字符串。 五大常用算法五大算法：分治，回溯，贪心，DP（动态规划），分支界定。内容在这一块是需要重点看看的，前4个是重点，也有非常多的经典例题。这一部分还是比较需要时间的，以下仅仅是介绍，点开链接具有详细的每个算法讲解。 1、分治法首先看一下二分搜索：一串数，取中间的数并且平分两半，如果比中间数大，就去上半部分找，然后再两半……这样查找就是分治思想：把一个问题分解成若干个一样的小块。具体详情：分治算法——五大常用算法之一基本概念：把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题。直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。 2、动态规划法具体详情：动态规划——五大常用算法之一基本概念：动态规划（DP）就是：每走一步，都会根据之前的情况来决定这一步的走向，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。使用动态规划法一般会有一个递推公式（递推就是简单动态规划）。当然，最难找到的也是这个递推公式。 3、贪心算法具体详情：贪心算法——五大常用算法之一基本概念：在对问题求解时，总是做出在当前看来是最好的选择。不从整体最优上加以考虑，所做出的仅是在某种意义上的局部最优解。贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。 4、回溯算法具体详情：回溯算法——五大常用算法之一基本概念： 回溯算法实际上一个类似枚举的搜索尝试过程（排列组合），主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。 许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。 5、分支界定这个算法个人没有仔细研究，可能是因为学的较浅没有经常用到。下面内容做一个参考：基本描述 类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。","categories":[{"name":"算法排序","slug":"算法排序","permalink":"http://blog.yuewei.fun/categories/算法排序/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://blog.yuewei.fun/tags/算法/"}]},{"title":"常用排序","slug":"排序","date":"2019-08-03T06:48:39.000Z","updated":"2019-08-06T06:04:54.030Z","comments":true,"path":"2019/08/03/排序/","link":"","permalink":"http://blog.yuewei.fun/2019/08/03/排序/","excerpt":"冒泡排序思路分析：在要排序的切片中，对当前还未排好的序列，从前往后对相邻的两个元素依次进行比较和调整，让较大的数往下沉，较小的往上冒。即，每当两相邻的元素比较后发现它们的排序与排序要求相反时，就将它们互换。","text":"冒泡排序思路分析：在要排序的切片中，对当前还未排好的序列，从前往后对相邻的两个元素依次进行比较和调整，让较大的数往下沉，较小的往上冒。即，每当两相邻的元素比较后发现它们的排序与排序要求相反时，就将它们互换。 1234567891011121314151617181920212223242526package mainimport ( &quot;fmt&quot;)var sli = []int&#123;1, 43, 54, 62, 21, 66, 32, 78, 36, 76, 39&#125;func bubbleSort(sli []int) []int &#123; len := len(sli) //该层循环控制 需要冒泡的轮数 for i := 1; i &lt; len; i++ &#123; //该层循环用来控制每轮 冒出一个数 需要比较的次数 for j := 0; j &lt; len-1; j++ &#123; if sli[i] &lt; sli[j] &#123; sli[i], sli[j] = sli[j], sli[i] &#125; &#125; &#125; return sli&#125;func main() &#123; res := bubbleSort(sli) fmt.Println(res)&#125; 选择排序思路分析：在要排序的切片中，选出最小的一个元素与第一个位置的元素交换。然后在剩下的元素当中再找最小的与第二个位置的元素交换，如此循环到倒数第二个元素和最后一个元素比较为止。 12345678910111213141516171819202122232425262728package mainimport ( &quot;fmt&quot;)var sli = []int&#123;1, 43, 54, 62, 21, 66, 32, 78, 36, 76, 39&#125;func selectSort(sli []int) []int &#123; //双重循环完成，外层控制轮数，内层控制比较次数 len := len(sli) for i := 0; i &lt; len-1; i++ &#123; //先假设最小的值的位置 k := i for j := i + 1; j &lt; len; j++ &#123; //sli[k] 是当前已知的最小值 if sli[k] &gt; sli[j] &#123; //比较，发现更小的,记录下最小值的位置；并且在下次比较时采用已知的最小值进行比较。 k = j &#125; &#125; //已经确定了当前的最小值的位置，保存到 k 中。如果发现最小值的位置与当前假设的位置 i 不同，则位置互换即可。 if k != i &#123; sli[k], sli[i] = sli[i], sli[k] &#125; &#125; return sli&#125; 插入排序思路分析：在要排序的一切片中，假设前面的元素已经是排好顺序的，现在要把第n个元素插到前面的有序切片中，使得这n个元素也是排好顺序的。如此反复循环，直到全部排好顺序。 123456789101112131415161718192021222324252627282930package mainimport ( &quot;fmt&quot;)var sli = []int&#123;1, 43, 54, 62, 21, 66, 32, 78, 36, 76, 39&#125;func insertSort(sli []int) []int &#123; len := len(sli) for i := 0; i &lt; len; i++ &#123; tmp := sli[i] //内层循环控制，比较并插入 for j := i - 1; j &gt;= 0; j-- &#123; if tmp &lt; sli[j] &#123; //发现插入的元素要小，交换位置，将后边的元素与前面的元素互换 sli[j+1], sli[j] = sli[j], tmp &#125; else &#123; //如果碰到不需要移动的元素，则前面的就不需要再次比较了。 break &#125; &#125; &#125; return sli&#125;func main() &#123; res := insertSort(sli) fmt.Println(res)&#125; 快速排序思路分析：选择一个基准元素，通常选择第一个元素或者最后一个元素。通过一趟扫描，将待排序列分成两部分，一部分比基准元素小，一部分大于等于基准元素。此时基准元素在其排好序后的正确位置，然后再用同样的方法递归地排序划分的两部分。 123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( &quot;fmt&quot;)var sli = []int&#123;1, 43, 54, 62, 21, 66, 32, 78, 36, 76, 39&#125;func quickSort(sli []int) []int &#123; //先判断是否需要继续进行 len := len(sli) if len &lt;= 1 &#123; return sli &#125; //选择第一个元素作为基准 base_num := sli[0] //遍历除了标尺外的所有元素，按照大小关系放入左右两个切片内 //初始化左右两个切片 left_sli := []int&#123;&#125; //小于基准的 right_sli := []int&#123;&#125; //小于基准的 for i := 1; i &lt; len; i++ &#123; if base_num &gt; sli[i] &#123; //放入左边切片 left_sli = append(left_sli, sli[i]) &#125; else &#123; //放入右边切片 right_sli = append(right_sli, sli[i]) &#125; &#125; //再分别对左边和右边的切片进行相同的排序处理方式递归调用这个函数 left_sli = quickSort(left_sli) right_sli = quickSort(right_sli) //合并 left_sli = append(left_sli, base_num) return append(left_sli, right_sli...)&#125;func main() &#123; res := quickSort(sli) fmt.Println(res)&#125;","categories":[{"name":"算法排序","slug":"算法排序","permalink":"http://blog.yuewei.fun/categories/算法排序/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://blog.yuewei.fun/tags/排序/"},{"name":"算法","slug":"算法","permalink":"http://blog.yuewei.fun/tags/算法/"}]},{"title":"二叉树","slug":"二叉树","date":"2019-08-02T09:22:54.000Z","updated":"2019-08-02T09:31:49.611Z","comments":true,"path":"2019/08/02/二叉树/","link":"","permalink":"http://blog.yuewei.fun/2019/08/02/二叉树/","excerpt":"回顾整理二叉树遍历相关内容。 对于二叉树而言，其遍历有两种方式，一种是深度优先，即先优先向下进行遍历，一种是广度优先，逐层向下遍历。","text":"回顾整理二叉树遍历相关内容。 对于二叉树而言，其遍历有两种方式，一种是深度优先，即先优先向下进行遍历，一种是广度优先，逐层向下遍历。 二叉树结构12345type Tree struct &#123; Val int Left *Tree Right *Tree&#125; 深度优先搜索Deepth-First-Search DFS， 对于深度优先而言，又有三种方式，即前序，中序和后序。前中后序之间的前中后，指的是根结点的位置。 前序递归12345678910func PreOrder(root *Tree) []int &#123; var result []int if root == nil &#123; return result &#125; result = append(result, root.Val) result = append(result, PreOrder(root.Left)...) result = append(result, PreOrder(root.Right)...) return result&#125; 前序非递归123456789101112131415161718192021func PreOrderNonRecursive(root *Tree) []int &#123; var result []int if root == nil &#123; return result &#125; stack := list.New() p := root for p != nil || stack.Len() != 0 &#123; for p != nil &#123; result = append(result, p.Val) stack.PushBack(p) p = p.Left &#125; if stack.Len() != 0 &#123; node := stack.Back() stack.Remove(node) p = node.Value.(*Tree).Right &#125; &#125; return result&#125; 中序递归12345678910func InOrder(root *Tree) []int &#123; var result []int if root == nil &#123; return nil &#125; result = append(result, PreOrder(root.Left)...) result = append(result, root.Val) result = append(result, PreOrder(root.Right)...) return result&#125; 中序非递归123456789101112131415161718192021func InOrderNonRecursive(root *Tree) []int &#123; var result []int if root == nil &#123; return result &#125; stack := list.New() p := root for p != nil || stack.Len() != 0 &#123; for p != nil &#123; stack.PushBack(p) p = p.Left &#125; if stack.Len() != 0 &#123; node := stack.Back() stack.Remove(node) result = append(result, node.Value.(*Tree).Val) p = node.Value.(*Tree).Right &#125; &#125; return result&#125; 后序递归12345678910func PostOrder(root *Tree) []int &#123; var result []int if root == nil &#123; return nil &#125; result = append(result, PreOrder(root.Left)...) result = append(result, PreOrder(root.Right)...) result = append(result, root.Val) return result&#125; 后序非递归1234567891011121314151617181920212223242526func PostOrderNonRecursive(root *Tree) []int &#123; var result []int if root == nil &#123; return result &#125; stack := list.New() p := root lastVisit := new(Tree) for p != nil || stack.Len() != 0 &#123; for p != nil &#123; stack.PushBack(p) p = p.Left &#125; if stack.Len() != 0 &#123; node := stack.Back() if node.Value.(*Tree).Right != nil &amp;&amp; lastVisit != node.Value.(*Tree).Right &#123; p = node.Value.(*Tree).Right continue &#125; result = append(result, node.Value.(*Tree).Val) stack.Remove(node) lastVisit = node.Value.(*Tree) &#125; &#125; return result&#125; 广度优先搜索Breadth-First-Search BFS 或者说是 Level Traversal，对于广度优先而言，其基于队列的数据结构，可以很简单的实现出来 1234567891011121314151617181920func LevelTraversal(root *Tree) []int &#123; var result []int if root == nil &#123; return result &#125; queue := list.New() queue.PushBack(root) for queue.Len() != 0 &#123; node := queue.Front() nTree := node.Value.(*Tree) queue.Remove(node) if nTree == nil &#123; continue &#125; result = append(result, nTree.Val) queue.PushBack(nTree.Left) queue.PushBack(nTree.Right) &#125; return result&#125; 需要注意在for循环里，不能直接用 node.Value.(*Tree) == nil 来判断，因为interface特性，会认为其不为 nil，哪怕nTree为nil。 详细内容，可以参考 go interface机制，这里侧重算法，不再细讲。总结 二叉树遍历分为两种，一种是深度优先，一种是广度优先 深度优先分为前，中，后序三种实现方式 深度优先可以使用递归和非递归两种方式实现 深度优先主要借助栈来实现 广度优先主要借助队列来实现","categories":[{"name":"算法排序","slug":"算法排序","permalink":"http://blog.yuewei.fun/categories/算法排序/"}],"tags":[{"name":"排序","slug":"排序","permalink":"http://blog.yuewei.fun/tags/排序/"},{"name":"算法","slug":"算法","permalink":"http://blog.yuewei.fun/tags/算法/"}]},{"title":"更新","slug":"更新blog","date":"2019-08-02T03:37:17.098Z","updated":"2019-08-02T06:30:47.262Z","comments":true,"path":"2019/08/02/更新blog/","link":"","permalink":"http://blog.yuewei.fun/2019/08/02/更新blog/","excerpt":"博客内容更新","text":"博客内容更新 新建文章1$ hexo new \"My New Post\" 运行1$ hexo server 或 $hexo s 清空资源文件1$ hexo clean 重新生成资源文件1$ hexo generate 或 $ hexo g 发布文章到github.io1$ hexo deploy 或 hexo d","categories":[],"tags":[]}]}