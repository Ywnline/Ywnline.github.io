{"meta":{"title":"Ywnline","subtitle":null,"description":null,"author":"Ywnline","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"选择排序","slug":"选择排序","date":"2019-08-02T06:04:30.000Z","updated":"2019-08-02T06:31:00.781Z","comments":true,"path":"2019/08/02/选择排序/","link":"","permalink":"http://yoursite.com/2019/08/02/选择排序/","excerpt":"思路分析：在要排序的切片中，选出最小的一个元素与第一个位置的元素交换。然后在剩下的元素当中再找最小的与第二个位置的元素交换，如此循环到倒数第二个元素和最后一个元素比较为止。","text":"思路分析：在要排序的切片中，选出最小的一个元素与第一个位置的元素交换。然后在剩下的元素当中再找最小的与第二个位置的元素交换，如此循环到倒数第二个元素和最后一个元素比较为止。 代码实现123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;fmt&quot;)var sli = []int&#123;1, 43, 54, 62, 21, 66, 32, 78, 36, 76, 39&#125;func selectSort(sli []int) []int &#123; //双重循环完成，外层控制轮数，内层控制比较次数 len := len(sli) for i := 0; i &lt; len-1; i++ &#123; //先假设最小的值的位置 k := i for j := i + 1; j &lt; len; j++ &#123; //sli[k] 是当前已知的最小值 if sli[k] &gt; sli[j] &#123; //比较，发现更小的,记录下最小值的位置；并且在下次比较时采用已知的最小值进行比较。 k = j &#125; &#125; //已经确定了当前的最小值的位置，保存到 k 中。如果发现最小值的位置与当前假设的位置 i 不同，则位置互换即可。 if k != i &#123; sli[k], sli[i] = sli[i], sli[k] &#125; &#125; return sli&#125;func main() &#123; res := selectSort(sli) fmt.Println(res)&#125;","categories":[],"tags":[{"name":"排序 算法","slug":"排序-算法","permalink":"http://yoursite.com/tags/排序-算法/"}]},{"title":"快速排序","slug":"快速排序","date":"2019-08-02T05:51:39.000Z","updated":"2019-08-02T06:30:26.765Z","comments":true,"path":"2019/08/02/快速排序/","link":"","permalink":"http://yoursite.com/2019/08/02/快速排序/","excerpt":"思路分析：选择一个基准元素，通常选择第一个元素或者最后一个元素。通过一趟扫描，将待排序列分成两部分，一部分比基准元素小，一部分大于等于基准元素。此时基准元素在其排好序后的正确位置，然后再用同样的方法递归地排序划分的两部分。","text":"思路分析：选择一个基准元素，通常选择第一个元素或者最后一个元素。通过一趟扫描，将待排序列分成两部分，一部分比基准元素小，一部分大于等于基准元素。此时基准元素在其排好序后的正确位置，然后再用同样的方法递归地排序划分的两部分。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142package mainimport ( &quot;fmt&quot;)var sli = []int&#123;1, 43, 54, 62, 21, 66, 32, 78, 36, 76, 39&#125;func quickSort(sli []int) []int &#123; //先判断是否需要继续进行 len := len(sli) if len &lt;= 1 &#123; return sli &#125; //选择第一个元素作为基准 base_num := sli[0] //遍历除了标尺外的所有元素，按照大小关系放入左右两个切片内 //初始化左右两个切片 left_sli := []int&#123;&#125; //小于基准的 right_sli := []int&#123;&#125; //小于基准的 for i := 1; i &lt; len; i++ &#123; if base_num &gt; sli[i] &#123; //放入左边切片 left_sli = append(left_sli, sli[i]) &#125; else &#123; //放入右边切片 right_sli = append(right_sli, sli[i]) &#125; &#125; //再分别对左边和右边的切片进行相同的排序处理方式递归调用这个函数 left_sli = quickSort(left_sli) right_sli = quickSort(right_sli) //合并 left_sli = append(left_sli, base_num) return append(left_sli, right_sli...)&#125;func main() &#123; res := quickSort(sli) fmt.Println(res)&#125;","categories":[],"tags":[{"name":"排序 算法","slug":"排序-算法","permalink":"http://yoursite.com/tags/排序-算法/"}]},{"title":"更新","slug":"更新blog","date":"2019-08-02T03:37:17.098Z","updated":"2019-08-02T06:30:47.262Z","comments":true,"path":"2019/08/02/更新blog/","link":"","permalink":"http://yoursite.com/2019/08/02/更新blog/","excerpt":"博客内容更新","text":"博客内容更新 新建文章1$ hexo new \"My New Post\" 运行1$ hexo server 或 $hexo s 清空资源文件1$ hexo clean 重新生成资源文件1$ hexo generate 或 $ hexo g 发布文章到github.io1$ hexo deploy 或 hexo d","categories":[],"tags":[]}]}